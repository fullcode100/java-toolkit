/*
 *  Copyright (c) 2020 - 2022 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.jackson.dto.v1;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import org.opentestfactory.jackson.dto.v1.utils.ListOf;

/** @author lpoma */
public class ExecutionResult extends org.opentestfactory.messages.ExecutionResult
    implements EventDtoBase {

  public static final String ATTACHMENT_KEY = "attachments";

  public ExecutionResult(
      @JsonProperty("apiVersion") String apiVersion,
      @JsonProperty("attachments") List<String> attachments,
      @JsonProperty("status") Integer status,
      @JsonProperty("logs") List<String> logs) {
    super(apiVersion, attachments, status, logs);
  }

  /**
   * Short story : Use {@link ExecutionResult#attachmentDetails()} instead of this one
   *
   * @deprecated
   *     <p>Long story : This method is deprecated because we shouldn't adhere to a degenerated data
   *     structure. By degenerated, I mean that the json structure is denormalized and... just
   *     weird. We should aim to have a clean domain/model, and thus we will use a sort of mini Anti
   *     Corruption Layer.
   */
  @Deprecated
  public Map<String, AttachmentStatusDTO> attachmentStatus() {
    Map<String, Object> deserializedAttachmentStatusMap =
        (Map<String, Object>) getMetadata().get(ATTACHMENT_KEY);
    if (deserializedAttachmentStatusMap == null) {
      return Collections.emptyMap();
    } else {
      Map<String, AttachmentStatusDTO> attachmentStatusMap = new HashMap<>();
      ObjectMapper mapper = new ObjectMapper();
      for (Map.Entry<String, Object> content : deserializedAttachmentStatusMap.entrySet()) {
        AttachmentStatusDTO attachmentStatusDTO =
            mapper.convertValue(content.getValue(), AttachmentStatusDTO.class);
        attachmentStatusMap.put(content.getKey(), attachmentStatusDTO);
      }
      return attachmentStatusMap;
    }
  }

  /**
   * Return a properly designed data structure for handling attachments... The json message is
   * poorly designed, and thus we need to transform attachment data to protect our code from the
   * weird json schema.
   *
   * @return The attachment as a collection. Nothing fancy, just a simple collection of dedicated
   *     object with some useful methods.
   */
  public Attachments attachmentDetails() {
    Map<String, Object> deserializedAttachmentStatusMap =
        (Map<String, Object>) getMetadata().get(ATTACHMENT_KEY);
    // Guarding again the FANTASTIC idea to forbid empty collections (empty map, empty lists) in
    // json schema
    // but allowing null values
    if (deserializedAttachmentStatusMap == null) {
      return new Attachments(Collections.emptyList());
    } else {
      ObjectMapper mapper = new ObjectMapper();
      // Now we convert the internal attachment map to a proper list :
      // - Each element of the list contains all data for one attachment (no more data exploded in
      // several properties)
      // - The order from attachment String[] is preserved,
      //   so the consumer doesn't need to take care of order each time it use the attachments
      List<Attachment> attachments =
          getAttachments().stream()
              .map(
                  path -> {
                    Object deserializedAttachment = deserializedAttachmentStatusMap.get(path);
                    AttachmentStatusDTO attachmentStatusDTO =
                        mapper.convertValue(deserializedAttachment, AttachmentStatusDTO.class);
                    return new Attachment(
                        attachmentStatusDTO.getUuid(), attachmentStatusDTO.getType(), path);
                  })
              .collect(Collectors.toList());
      return new Attachments(attachments);
    }
  }

  /**
   * Shortcut to get optional metadata step_origin_status. Reserved for end-step and end-job events.
   */
  public List<StepStatusDTO> stepOriginStatus() {
    Map<String, Object> stepOriginStatusList =
        (Map<String, Object>) getMetadata().get("step_origin_status");
    if (stepOriginStatusList == null) {
      return Collections.emptyList();
    } else {
      return stepOriginStatusList.entrySet().stream()
          .map(entry -> new StepStatusDTO((String) entry.getKey(), (Integer) entry.getValue()))
          .collect(Collectors.toList());
    }
  }

  /**
   * Calculate the total number of results generated from the step uuid provided. Used to know how
   * many ExecutionResult are expected by a publisher module before trying to parse their
   * attachments/test reports.
   *
   * @param stepUuid
   * @return the total number of ExecutionResult linked to the step whose uuid is provided. Returns
   *     <code>null</code> if the expected number is not yet known (the number of executed commands
   *     may change as a result of conditional step execution in the workflow).
   */
  public Integer getNbResult(String stepUuid) {
    Objects.requireNonNull(stepUuid, "Step UUIT cannot be null.");
    Integer nbResult = null;
    for (StepStatusDTO status : stepOriginStatus()) {
      if (stepUuid.equals(status.getStepUuid())) {
        nbResult = status.getNbResult();
      }
    }
    return nbResult;
  }

  public ExecutionResult addAttachment(Attachment attachment) {
    Map<String, Object> deserializedAttachmentStatusMap =
        (Map<String, Object>) getMetadata().getOrDefault(ATTACHMENT_KEY, new HashMap<>());
    deserializedAttachmentStatusMap.put(
        attachment.url, new AttachmentStatusDTO(attachment.uuid, attachment.type));
    this.addMetadata(ATTACHMENT_KEY, deserializedAttachmentStatusMap);
    return this;
  }

  /**
   * @deprecated This class should be private because it mirrors a weird data structure from json
   *     schema. We will make it private after refactoring legacy code that uses it.
   */
  @Deprecated
  @JsonIgnoreProperties(ignoreUnknown = true)
  public static class AttachmentStatusDTO {

    private String uuid;
    private String type;

    public AttachmentStatusDTO(
        @JsonProperty("uuid") String uuid, @JsonProperty("type") String type) {
      this.uuid = uuid;
      this.type = type;
    }

    public String getUuid() {
      return uuid;
    }

    public String getType() {
      return type;
    }
  }

  /**
   * Technical class to facilitate the mapping between a step and the number of ExecutionResult it
   * has generated during its lifecycle
   */
  public static class StepStatusDTO {

    private final String stepUuid;
    private final Integer nbResult;

    public StepStatusDTO(
        @JsonProperty("step_uuid") String stepUuid, @JsonProperty("nb_result") Integer nbResult) {
      this.stepUuid = stepUuid;
      this.nbResult = nbResult;
    }

    public String getStepUuid() {
      return stepUuid;
    }

    public Integer getNbResult() {
      return nbResult;
    }
  }

  public static class Attachments extends ListOf<Attachment> {

    public Attachments(List<Attachment> attachments) {
      super(attachments);
    }
  }

  public static class Attachment {
    private final String uuid;
    private final String type;
    private final String url;

    public Attachment(String uuid, String type, String url) {
      this.uuid = uuid;
      this.type = type;
      this.url = Objects.requireNonNull(url, "Attachment URL cannot be null");
    }

    public String getUuid() {
      return uuid;
    }

    public String getType() {
      return type;
    }

    public String getUrl() {
      return url;
    }
  }
}
