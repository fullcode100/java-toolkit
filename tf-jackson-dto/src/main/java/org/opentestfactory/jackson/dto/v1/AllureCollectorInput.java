/*
 *  Copyright (c) 2020 - 2022 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.jackson.dto.v1;

import static java.util.Objects.requireNonNull;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import org.opentestfactory.messages.OTFMessage;
import org.opentestfactory.utils.ObjectUtils;
import org.opentestfactory.utils.ValidationUtils;

public class AllureCollectorInput extends OTFMessage implements EventDtoBase {

  public static final String TEST_PLAN_ID_FIELD_KEY = "testPlanId";
  public static final String ATTACHMENTS_FIELD_KEY = "attachments";
  public static final String ALLURE_COLLECTOR_INPUT_KIND = "AllureCollectorInput";

  private final Map<String, Object> with;

  public AllureCollectorInput(
      @JsonProperty("apiVersion") String apiVersion,
      @JsonProperty("with") Map<String, Object> with) {
    super(apiVersion);
    this.with = with;
  }

  public String testPlanId() {
    return (String) getWith().get(TEST_PLAN_ID_FIELD_KEY);
  }

  public List<String> attachments() {
    if (getWith().containsKey(ATTACHMENTS_FIELD_KEY)) {
      return (List<String>) getWith().get(ATTACHMENTS_FIELD_KEY);
    } else {
      return new ArrayList<>();
    }
  }

  public String getKind() {
    return ALLURE_COLLECTOR_INPUT_KIND;
  }

  public String name() {
    return (String) getMetadata().get(NAME_KEY);
  }

  public String workflowId() {
    return (String) getMetadata().get(WORKFLOW_ID_KEY);
  }

  public String jobId() {
    return (String) getMetadata().get("job_id");
  }

  public List<String> jobOrigin() {
    return (List<String>) getMetadata().get("job_origin");
  }

  public Map<String, Object> getWith() {
    return Collections.unmodifiableMap(ObjectUtils.nonNullOrElse(with, Collections.emptyMap()));
  }

  public static class AllureCollectorInputBuilder {
    private final String apiVersion;
    private final MetadataBuilder metadataBuilder;
    private final WithBuilder withBuilder;

    public AllureCollectorInputBuilder(String apiVersion) {
      this.apiVersion = apiVersion;
      metadataBuilder = new MetadataBuilder(this);
      withBuilder = new WithBuilder(this);
    }

    public MetadataBuilder meta() {
      return this.metadataBuilder;
    }

    public WithBuilder with() {
      return this.withBuilder;
    }

    public AllureCollectorInput build() {
      Map<String, Object> metadata = metadataBuilder.buildMeta();
      Map<String, Object> with = withBuilder.buildWith();
      AllureCollectorInput allureCollectorInput = new AllureCollectorInput(apiVersion, with);
      allureCollectorInput.setMetadata(metadata);
      return allureCollectorInput;
    }
  }

  public static class MetadataBuilder {

    private final AllureCollectorInputBuilder allureCollectorInputBuilder;
    private String name;
    private String workflowId;

    public MetadataBuilder(AllureCollectorInputBuilder allureCollectorInputBuilder) {
      this.allureCollectorInputBuilder = allureCollectorInputBuilder;
    }

    public MetadataBuilder withName(String name) {
      this.name = requireNonNull(name);
      return this;
    }

    public MetadataBuilder withWorkflowId(String workflowId) {
      this.workflowId = requireNonNull(workflowId);
      return this;
    }

    public WithBuilder with() {
      return this.allureCollectorInputBuilder.with();
    }

    public AllureCollectorInput build() {
      return allureCollectorInputBuilder.build();
    }

    private Map<String, Object> buildMeta() {
      validate();
      return doBuild();
    }

    private Map<String, Object> doBuild() {
      Map<String, Object> meta = new HashMap<>();
      meta.put(NAME_KEY, name);
      meta.put(WORKFLOW_ID_KEY, workflowId);
      return meta;
    }

    private void validate() {
      ValidationUtils.requireNotBlank(name, NAME_KEY);
      ValidationUtils.requireNotBlank(workflowId, WORKFLOW_ID_KEY);
    }
  }

  public static class WithBuilder {

    private final AllureCollectorInputBuilder allureCollectorInputBuilder;
    private String testPlanId;
    private List<String> attachments;

    public WithBuilder(AllureCollectorInputBuilder allureCollectorInputBuilder) {
      this.allureCollectorInputBuilder = allureCollectorInputBuilder;
    }

    public WithBuilder withTestPlanId(String testPlanId) {
      this.testPlanId = testPlanId;
      return this;
    }

    public WithBuilder withAttachments(Collection<String> attachments) {
      // Schema require that attachment attribute can be missing but can't be empty list
      // Don't ask me why...
      if (Objects.nonNull(attachments) && !attachments.isEmpty()) {
        this.attachments = new ArrayList<>(attachments);
      }
      return this;
    }

    public AllureCollectorInput build() {
      return allureCollectorInputBuilder.build();
    }

    private Map<String, Object> buildWith() {
      validate();
      return doBuild();
    }

    private void validate() {
      ValidationUtils.requireNotBlank(testPlanId, TEST_PLAN_ID_FIELD_KEY);
    }

    private Map<String, Object> doBuild() {
      Map<String, Object> map = new HashMap<>();
      map.put(TEST_PLAN_ID_FIELD_KEY, testPlanId);
      if (Objects.nonNull(attachments)) {
        map.put(ATTACHMENTS_FIELD_KEY, Objects.requireNonNull(attachments));
      }
      return map;
    }
  }
}
