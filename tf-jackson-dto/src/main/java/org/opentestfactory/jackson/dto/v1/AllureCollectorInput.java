/*
 *  Copyright (c) 2020 - 2021 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.jackson.dto.v1;

import com.fasterxml.jackson.annotation.JsonProperty;
import org.opentestfactory.jackson.dto.v1.utils.ValidationUtils;
import org.opentestfactory.messages.OTFMessage;

import java.util.*;

import static java.util.Objects.requireNonNull;
import static org.opentestfactory.jackson.dto.v1.utils.ObjectUtils.nonNullOrElse;

public class AllureCollectorInput extends OTFMessage implements EventDtoBase {
    public static final String TEST_PLAN_ID_FIELD_KEY = "testPlanId";
    public static final String NAME_FIELD_KEY = "name";
    public static final String WORKFLOW_ID_FIELD_KEY = "workflow_id";
    public static final String ATTACHMENTS_FIELD_KEY = "attachments";

    private final Map<String, Object> with;

    public AllureCollectorInput(
            @JsonProperty("apiVersion") String apiVersion,
            @JsonProperty("with") Map<String, Object> with) {
        super(apiVersion);
        this.with = with;
    }

    public String testPlanId() {
        return (String) getWith().get(TEST_PLAN_ID_FIELD_KEY);
    }

    public List<String> attachments() {
        if (getWith().containsKey(ATTACHMENTS_FIELD_KEY)) {
            return (List<String>) getWith().get(ATTACHMENTS_FIELD_KEY);
        } else {
            return new ArrayList<>();
        }
    }

    public String getKind() {
        return "AllureCollectorInput";
    }

    public String name() {
        return (String) getMetadata().get(NAME_FIELD_KEY);
    }

    public String workflowId() {
        return (String) getMetadata().get(WORKFLOW_ID_FIELD_KEY);
    }

    public String jobId() {
        return (String) getMetadata().get("job_id");
    }

    public List<String> jobOrigin() {
        return (List<String>) getMetadata().get("job_origin");
    }

    public Map<String, Object> getWith() {
        return Collections.unmodifiableMap(nonNullOrElse(with, Collections.emptyMap()));
    }

    public static class AllureCollectorInputBuilder {
        private final String apiVersion;
        private final MetadataBuilder metadataBuilder;
        private final WithBuilder withBuilder;

        public AllureCollectorInputBuilder(String apiVersion) {
            this.apiVersion = apiVersion;
            metadataBuilder = new MetadataBuilder(this);
            withBuilder = new WithBuilder(this);
        }

        public MetadataBuilder meta() {
            return this.metadataBuilder;
        }

        public WithBuilder with() {
            return this.withBuilder;
        }

        public AllureCollectorInput build() {
            Map<String, Object> metadata = metadataBuilder.build();
            Map<String, Object> with = withBuilder.build();
            AllureCollectorInput allureCollectorInput = new AllureCollectorInput(apiVersion, with);
            allureCollectorInput.setMetadata(metadata);
            return allureCollectorInput;
        }
    }

    public static class MetadataBuilder {

        private final AllureCollectorInputBuilder allureCollectorInputBuilder;
        private String name;
        private String workflowId;

        public MetadataBuilder(AllureCollectorInputBuilder allureCollectorInputBuilder) {
            this.allureCollectorInputBuilder = allureCollectorInputBuilder;
        }

        public MetadataBuilder withName(String name) {
            this.name = requireNonNull(name);
            return this;
        }

        public MetadataBuilder withWorkflowId(String workflowId) {
            this.workflowId = requireNonNull(workflowId);
            return this;
        }

        public AllureCollectorInputBuilder endMeta() {
            return this.allureCollectorInputBuilder;
        }

        public Map<String, Object> build() {
            validate();
            return doBuild();
        }

        private Map<String, Object> doBuild() {
            Map<String, Object> meta = new HashMap<>();
            meta.put(NAME_FIELD_KEY, name);
            meta.put(WORKFLOW_ID_FIELD_KEY, workflowId);
            return meta;
        }

        private void validate() {
            ValidationUtils.requireNotBlank(name, "name");
            ValidationUtils.requireNotBlank(workflowId, "workflowId");
        }

    }

    public static class WithBuilder {

        private final AllureCollectorInputBuilder allureCollectorInputBuilder;
        private String testPlanId;
        private List<String> attachments;

        public WithBuilder(AllureCollectorInputBuilder allureCollectorInputBuilder) {
            this.allureCollectorInputBuilder = allureCollectorInputBuilder;
        }

        public WithBuilder withTestPlanId(String testPlanId) {
            this.testPlanId = testPlanId;
            return this;
        }

        public WithBuilder withAttachments(Collection<String> attachments) {
            // Schema require that attachment attribute can be missing but can't be empty list
            // Don't ask me why...
            if (Objects.nonNull(attachments) && !attachments.isEmpty()) {
                this.attachments = new ArrayList<>(attachments);
            }
            return this;
        }

        public AllureCollectorInputBuilder endWith() {
            return allureCollectorInputBuilder;
        }

        public Map<String, Object> build() {
            validate();
            return doBuild();
        }

        private void validate() {
            ValidationUtils.requireNotBlank(testPlanId, "testPlanId");
        }

        private Map<String, Object> doBuild() {
            Map<String, Object> map = new HashMap<>();
            map.put(TEST_PLAN_ID_FIELD_KEY, testPlanId);
            if (Objects.nonNull(attachments)) {
                map.put(ATTACHMENTS_FIELD_KEY, Objects.requireNonNull(attachments));
            }
            return map;
        }
    }
}
