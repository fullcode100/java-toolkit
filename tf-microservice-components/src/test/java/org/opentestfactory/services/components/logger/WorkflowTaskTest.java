/*
 *  Copyright (c) 2020 - 2023 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.services.components.logger;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.junit.Assert;
import org.junit.Test;
import org.slf4j.LoggerFactory;

/** @author edegenetais */
public class WorkflowTaskTest {

  @Test(timeout = 10 * 1000)
  public void cleanupWhenSuccess() throws InterruptedException {

    final WorkflowEvent event =
        WorkflowEventTestHelper.getEventWithWorkflowIdOnly(UUID.randomUUID().toString());
    WorkflowContext.registerWorflowContext(new WorkflowContext(event));

    WorkflowTaskTestee testee =
        new WorkflowTaskTestee() {
          @Override
          public void testTask() {
            LoggerFactory.getLogger(getClass()).info("Test task done !");
          }
        };

    testee.launch();
    testee.join();

    Assert.assertNotNull("Context in the main thread should exist", WorkflowContext.get());
    Assert.assertNull("Context was not properly cleaned up", testee.finalWorkflowContext());
  }

  @Test(timeout = 10 * 1000)
  public void cleanupWhenException() throws InterruptedException {

    final WorkflowEvent event =
        WorkflowEventTestHelper.getEventWithWorkflowIdOnly(UUID.randomUUID().toString());
    WorkflowContext.registerWorflowContext(new WorkflowContext(event));

    WorkflowTaskTestee testee =
        new WorkflowTaskTestee() {
          @Override
          public void testTask() {
            throw new UnsupportedOperationException(
                "This exception should not prevent workflow cleanup.");
          }
        };

    testee.launch();
    testee.join();

    Assert.assertNotNull("Context in the main thread should exist", WorkflowContext.get());
    Assert.assertNull("Context was not properly cleaned up", testee.finalWorkflowContext());
  }

  @Test(timeout = 10 * 1000)
  public void mainThreadWorkflowContextShouldExistDuringTask() throws InterruptedException {

    final String workflowId = UUID.randomUUID().toString();
    final WorkflowEvent event = WorkflowEventTestHelper.getEventWithWorkflowIdOnly(workflowId);
    WorkflowContext.registerWorflowContext(new WorkflowContext(event));

    final List<String> hasContext = new ArrayList<>();
    WorkflowTaskTestee testee =
        new WorkflowTaskTestee() {
          @Override
          public void testTask() {
            if (WorkflowContext.get() != null) {
              hasContext.add(WorkflowContext.get().workflowId);
            }
          }
        };

    testee.launch();
    testee.join();

    Assert.assertNotNull("Context in the main thread should exist", WorkflowContext.get());
    Assert.assertTrue("Task should have found workflow context", !hasContext.isEmpty());
    Assert.assertEquals("Context should be the same as main.", workflowId, hasContext.get(0));
  }

  @Test(timeout = 10 * 1000)
  public void doNotInventWorkflowContextDuringTask() throws InterruptedException {

    // Just to make sure
    WorkflowContext.cleanWorkflowContextUp();

    final List<Boolean> hasContext = new ArrayList<>();
    WorkflowTaskTestee testee =
        new WorkflowTaskTestee() {
          @Override
          public void testTask() {
            hasContext.add(WorkflowContext.get() != null);
          }
        };

    testee.launch();
    testee.join();

    Assert.assertNull("Context in the main thread should NOT exist", WorkflowContext.get());
    Assert.assertTrue("Task should have been run", !hasContext.isEmpty());
    Assert.assertFalse("There should be no context during the class", hasContext.get(0));
  }

  /**
   * To test the behavior of a task we need a concrete task, with a task implementation relevant for
   * the test case. But we also need a bit of boiler plate to handle synchronisation between the
   * test thread and task thread. This base class handles this.
   */
  private abstract static class WorkflowTaskTestee extends WorkflowTask {
    private Thread taskThread;
    private WorkflowContext finalWfContext;

    @Override
    protected void doTask() {
      taskThread = Thread.currentThread();
      testTask();
    }

    @Override
    public void launch() {
      final WorkflowTaskTestee task = this;
      Runnable testRunnable =
          new Runnable() {
            public void run() {
              task.run();
              finalWfContext = WorkflowContext.get();
            }
          };
      new Thread(testRunnable).start();
    }

    public void join() throws InterruptedException {
      while (taskThread == null) {
        Thread.yield();
      }
      taskThread.join();
    }

    public WorkflowContext finalWorkflowContext() {
      return finalWfContext;
    }

    public abstract void testTask();
  }
}
