/*
 *  Copyright (c) 2020 - 2021 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.services.dto.v1;

import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * @author akatz
 *
 * This message is sent by the publisher to the report interpreter.
 */
public class ReportInterpreterInput extends AbstractReportInterpreterEvent {


    private final Map<String,Object> with;

    public ReportInterpreterInput(
        @JsonProperty("apiVersion") String apiVersion,
        @JsonProperty("with") Map<String,Object> with
    ) {
        super(apiVersion);
        this.with = with;
    }

    public String testTechnology() {
        if (getWith().containsKey("testTechnology")) {
            return getWith().get("testTechnology").toString();
        } else {
            return null;
        }
    }

    public String testDefinition() {
        if (getWith().containsKey("testDefinition")) {
            return getWith().get("testDefinition").toString();
        } else {
            return null;
        }
    }

    public List<String> attachments() {
        if(getWith().containsKey("attachments")) {
            return (List<String>)getWith().get("attachments");
        } else {
            return new ArrayList<>();
        }
    }

    public String getKind(){
        return "ReportInterpreterInput";
    }

    public String name(){
        return (String)getMetadata().get("name");
    }

    public String workflowId(){
        return (String)getMetadata().get("workflow_id");
    }

    public String jobId(){
        return (String)getMetadata().get("job_id");
    }

    public List<String> jobOrigin(){
        return (List<String>) getMetadata().get("job_origin");
    }

    public String stepId() {
        return (String)getMetadata().get("step_id");
    }

    public Map<String,Object> getWith(){
        return Collections.unmodifiableMap(Objects.requireNonNullElse(with, Collections.emptyMap()));
    }
}

