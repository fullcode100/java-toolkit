/*
 *  Copyright (c) 2020 - 2022 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.services.components.validation;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.networknt.schema.JsonSchema;
import com.networknt.schema.JsonSchemaFactory;
import com.networknt.schema.SpecVersion;
import com.networknt.schema.ValidationMessage;
import com.nimbusds.jose.util.IOUtils;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import javax.inject.Inject;
import javax.ws.rs.ext.Provider;
import javax.ws.rs.ext.ReaderInterceptor;
import javax.ws.rs.ext.ReaderInterceptorContext;
import org.glassfish.jersey.server.ResourceConfig;
import org.opentestfactory.messages.InvalidOtfMessageException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** @author edegenetais */
@Provider
public class JsonSchemaReaderInterceptor implements ReaderInterceptor {

  private static final Logger LOGGER = LoggerFactory.getLogger(JsonSchemaReaderInterceptor.class);

  private final List<ExpectedKind> acceptedEvents = new ArrayList<>();

  @Inject
  public JsonSchemaReaderInterceptor(ResourceConfig cfg) {
    LOGGER.info("Configuration : {}", cfg);
    cfg.getClasses().stream()
        .filter(componentClass -> !componentClass.getPackage().equals(getClass().getPackage()))
        .filter(componentClass -> !componentClass.getName().startsWith("org.glassfish."))
        .forEach(
            componentClass -> {
              LOGGER.debug(
                  "Analyzing configuration class {} as Inbox candidate", componentClass.getName());
              for (Method inboxCandidate : componentClass.getMethods()) {
                final ExpectedKind[] annotationsByType =
                    inboxCandidate.getAnnotationsByType(ExpectedKind.class);
                for (ExpectedKind expectedKind : annotationsByType) {
                  acceptedEvents.add(expectedKind);
                }
              }
            });
  }

  /**
   * Implementation of the {@link
   * ReaderInterceptor#aroundReadFrom(javax.ws.rs.ext.ReaderInterceptorContext)} method that checks
   * incoming messages against the relevant json schema.
   *
   * @param arg0
   * @return
   * @throws IOException
   */
  @Override
  public Object aroundReadFrom(ReaderInterceptorContext arg0) throws IOException {
    String content = IOUtils.readInputStreamToString(arg0.getInputStream());
    arg0.setInputStream(new ByteArrayInputStream(content.getBytes()));

    ObjectMapper mapper = new ObjectMapper();
    JsonNode contentNode = mapper.readTree(content);
    String messageKind = (String) mapper.readValue(content, HashMap.class).get("kind");
    String rawApiVersion = (String) mapper.readValue(content, HashMap.class).get("apiVersion");

    if (acceptedEvents.stream()
        .noneMatch(
            kind -> kind.value().equals(messageKind) && kind.apiVersion().equals(rawApiVersion))) {
      throw new UnexpectedEventKindException(acceptedEvents, rawApiVersion + "/" + messageKind);
    }

    JsonSchemaFactory schemaFactory =
        JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V201909);
    try (InputStream schemaIs =
        getSchemaResourceAsInputStream(messageKind, apiVersionToNamespacePath(rawApiVersion))) {
      JsonSchema schema = schemaFactory.getSchema(schemaIs);
      Set<ValidationMessage> validationResult = schema.validate(contentNode);
      if (validationResult.isEmpty()) {
        LoggerFactory.getLogger(JsonSchemaReaderInterceptor.class)
            .debug(
                "Using validation against the {} schema, accepted message {}.",
                messageKind,
                content);
      } else {
        throw new JsonSchemaReaderInvalidOtfMessageException(validationResult, messageKind);
      }
    }
    return arg0.proceed();
  }

  private InputStream getSchemaResourceAsInputStream(String messageKind, String namespace) {
    final String schemaResourceName = namespace + "/" + messageKind + ".json";
    LOGGER.info("Schema resource name : {}", schemaResourceName);
    InputStream currentContextResourceStream =
        Thread.currentThread().getContextClassLoader().getResourceAsStream(schemaResourceName);
    if (currentContextResourceStream == null) {
      final InputStream resourceAsStream = getClass().getResourceAsStream(schemaResourceName);
      if (resourceAsStream == null) {
        String message = "Unknown message type " + namespace + "/" + messageKind;
        LOGGER.error(message);
        throw new BadValidationSetupException(message);
      }
      return resourceAsStream;
    } else {
      return currentContextResourceStream;
    }
  }

  /**
   * Converts the String extracted from the event's apiVersion property to a namespace path where
   * the message schema can be found
   *
   * @param rawApiVersion : a string similar to : "opentestfactory.org/v1alpha1"
   * @return a string similar to : "/org/opentestfactory/json/schema/v1alpha1/"
   */
  private String apiVersionToNamespacePath(String rawApiVersion) {
    String[] apiVersionParts = rawApiVersion.split("/");
    final String versionPart = apiVersionParts[1];
    String namespaceParts[] = apiVersionParts[0].split("\\.");
    StringBuilder namespacePath = new StringBuilder();
    for (int i = namespaceParts.length - 1; i >= 0; i--) {
      namespacePath.append(namespaceParts[i]).append("/");
    }
    return "/" + namespacePath + "json/schema/" + versionPart;
  }

  static class JsonSchemaReaderInvalidOtfMessageException extends InvalidOtfMessageException {

    public JsonSchemaReaderInvalidOtfMessageException(
        Set<ValidationMessage> validationMessages, String schemaKind) {
      super(buildErrorMessage(validationMessages), schemaKind);
    }

    private static String buildErrorMessage(Set<ValidationMessage> validationMessages) {
      StringBuilder message = new StringBuilder();
      validationMessages.stream()
          .forEach(report -> message.append(report.getMessage()).append('\n'));
      return message.toString();
    }
  }

  static class UnexpectedEventKindException extends InvalidOtfMessageException {

    /**
     * {@link InvalidOtfMessageException} subtype thrown when the incoming message doesn't belong to
     * an expected kind.
     *
     * @param acceptedEvents list of accepted kinds.
     * @param qualifiedKind kind of the rejected message, qualified by its api version.
     */
    public UnexpectedEventKindException(List<ExpectedKind> acceptedEvents, String qualifiedKind) {
      super(buildWarningMessage(acceptedEvents, qualifiedKind), qualifiedKind);
    }

    private static String buildWarningMessage(
        List<ExpectedKind> acceptedEvents, String qualifiedKind) {
      StringBuilder message =
          new StringBuilder()
              .append("The event ")
              .append(qualifiedKind)
              .append(" is not accepted by this module. List of accepted events :\n");
      acceptedEvents.forEach(
          event -> {
            message.append(event.apiVersion()).append('/');
            message.append(event.value()).append('\n');
          });
      return message.toString();
    }
  }
}
