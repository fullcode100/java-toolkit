/*
 *  Copyright (c) 2020 - 2022 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.services.components.logger;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import org.opentestfactory.jackson.dto.v1.WorkflowLogNotification;
import org.opentestfactory.messages.OTFMessageAPI;
import org.opentestfactory.services.components.bus.BusClient;
import org.opentestfactory.services.components.bus.BusClientFactory;
import org.opentestfactory.services.components.bus.BusClientFactoryConfiguration;
import org.springframework.util.StringUtils;

/**
 * This logback appender publishes workflow-related logs as notifications.
 *
 * @author edegenetais
 */
public class WorkflowAppender extends ch.qos.logback.core.AppenderBase {
  private static final Integer DEFAULT_QUEUE_SIZE = 100;

  private URL busBaseUrl;
  private String busToken;
  private BusClient busClient;
  private boolean run = false;

  private LinkedBlockingQueue<WorkflowLogNotification> loggingQueue =
      new LinkedBlockingQueue<>(DEFAULT_QUEUE_SIZE);
  // This was made protected to make tests easier.
  protected Thread publicationWorker;

  public synchronized void setBusBaseUrl(String busUrl) throws MalformedURLException {
    addInfo("Workflow Logging : target bus URL: " + busUrl);
    this.busBaseUrl = new URL(busUrl);
    this.busClient = null;
  }

  public synchronized void setBusToken(String busToken) {
    addInfo(
        "Workflow Logging : "
            + (StringUtils.isEmpty(busToken) ? "anonymous mode" : " JWT authentication set"));
    this.busToken = busToken;
    this.busClient = null;
  }

  public synchronized void setQueueSize(Integer size) {
    if (run) {
      throw new IllegalStateException("Already running, cannot change queue size.");
    } else {
      addInfo("Logging queue size will be: " + size);
      this.loggingQueue = new LinkedBlockingQueue<>(size);
    }
  }

  /** Appenders need to work quickly, so let's not recreate this client each time. */
  private synchronized BusClient getOrCreateBusClient() {
    if (this.busClient == null) {
      this.busClient =
          new BusClientFactory(new BusClientFactoryConfiguration(busBaseUrl, busToken))
              .getBusClient();
    }
    return this.busClient;
  }

  @Override
  public void start() {
    super.start();
    this.run = true;
    this.publicationWorker = new WorkflowAppenderWorker();
    this.publicationWorker.start();
    addInfo("Started");
  }

  @Override
  public void stop() {
    this.run = false;
    addInfo("Initiated stop.");
    super.stop();
  }

  @Override
  protected void append(Object e) {
    addInfo("Got message");
    WorkflowContext ctx = WorkflowContext.get();
    if (ctx != null) {
      addInfo("In workflow, queing notification");
      final WorkflowLogNotification notification =
          new WorkflowLogNotification(
              OTFMessageAPI.CURRENT_API_VERSION,
              getName(),
              ctx.workflowId,
              new WorkflowLogNotification.LogSpec(e.toString()));
      if (loggingQueue.offer(notification)) {
        addInfo("Notification queued");
      } else {
        addInfo("The queue is full, publishing old messages before enquing.");
        do {
          WorkflowLogNotification oldNotification = loggingQueue.poll();
          getOrCreateBusClient().publishEvent(oldNotification);
        } while (!loggingQueue.offer(notification));
      }
    }
  }

  private void publish() throws InterruptedException {
    while (run) {
      WorkflowLogNotification notification = loggingQueue.poll(500, TimeUnit.MILLISECONDS);
      while (notification != null) {
        addInfo("Publishing message as notification.");
        try {
          getOrCreateBusClient().publishEvent(notification);
        } catch (RuntimeException e) {
          // The exception may be shown as swallowed in analysis tools, but this is how we log an
          // exception from within the logging framework.
          addError("Failed to publish log " + notification.spec.logs, e);
        }
        notification = loggingQueue.poll();
      }
    }
    addInfo("Got out of publishing main loop.");
  }

  private class WorkflowAppenderWorker extends Thread {

    public WorkflowAppenderWorker() {
      setDaemon(true);
      setName("WFAppenderPublicationWorker-" + hashCode());
    }

    @Override
    public void run() {
      try {
        publish();
      } catch (InterruptedException ex) {
        addWarn("Logging worker thread interrupted " + ex.getMessage());
        Thread.currentThread().interrupt();
      }
    }
  }
}
