/*
 *  Copyright (c) 2020 - 2023 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.services.components.auth;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWSVerifier;
import com.nimbusds.jose.crypto.factories.DefaultJWSVerifierFactory;
import com.nimbusds.jose.proc.JWSVerifierFactory;
import com.nimbusds.jwt.SignedJWT;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.security.Key;
import java.text.ParseException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.core.MediaType;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.openssl.PEMException;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * This filter checks if authentication is needed per the active configuration and if so, checks if
 * the JWT auth token was sent and is valid.
 *
 * @author edegenetais
 */
@Component
public class JwtAuthFilter implements Filter {

  private static final Logger LOGGER = LoggerFactory.getLogger(JwtAuthFilter.class);

  private AuthConfiguration cfg;

  public JwtAuthFilter(AuthConfiguration cfg) {
    this.cfg = cfg;
    LOGGER.debug("JWTAuth filter created, {} mode.", cfg.anonymousAllowed() ? "test" : "secure");
  }

  @Override
  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)
      throws IOException, ServletException {
    LOGGER.trace("Applying JWT auth filter");
    HttpServletRequest req = (HttpServletRequest) request;
    if (cfg.anonymousAllowed()
        && (req.getLocalAddr().matches("127.0.0.[12]?[0-9]?[0-9]")
            || req.getLocalAddr().matches("0:0:0:0:0:0:0:[0-9a-f]+"))) {
      filterChain.doFilter(request, response);
    } else {
      String header = req.getHeader("Authorization");
      if (header == null || header.trim().length() == 0) {
        sendJsonErrorStatus(response, "Unauthenticated", 401);
      } else {
        checkAuthorizationHeader(header, filterChain, request, response);
      }
    }
  }

  private void checkAuthorizationHeader(
      String header, FilterChain filterChain, ServletRequest request, ServletResponse response)
      throws IOException, ServletException {
    String[] headerParts = header.split(" ");
    if (headerParts.length == 2 && "bearer".equalsIgnoreCase(headerParts[0])) {
      if (isValidHeader(headerParts[1])) {
        filterChain.doFilter(request, response);
      } else {
        sendInvalidTokenError(response);
      }
    } else {
      sendInvalidTokenError(response);
    }
  }

  private boolean isValidHeader(String token) throws IOException {
    try {
      SignedJWT jwt = SignedJWT.parse(token);
      JWSVerifierFactory f = new DefaultJWSVerifierFactory();
      for (File keyLocation : cfg.trustedAutorities()) {
        if (checkTokenAgainstPublicKey(keyLocation, f, jwt)) {
          return true;
        }
      }
    } catch (ParseException ex) {
      LOGGER.debug("Token parsing error", ex);
    }
    return false;
  }

  private boolean checkTokenAgainstPublicKey(File keyLocation, JWSVerifierFactory f, SignedJWT jwt)
      throws IOException {
    try (FileReader fr = new FileReader(keyLocation); ) {
      PEMParser pemParser = new PEMParser(fr);
      JcaPEMKeyConverter converter = new JcaPEMKeyConverter();
      SubjectPublicKeyInfo info = SubjectPublicKeyInfo.getInstance(pemParser.readObject());
      Key key = converter.getPublicKey(info);
      JWSVerifier v = f.createJWSVerifier(jwt.getHeader(), key);
      if (jwt.verify(v)) {
        return true;
      }
      // Need to catch the PEMException because it fails silently when invalid token/public key
      // association is provided
      // throwing an unsuitable NullPointerException that mislead the user
    } catch (PEMException e) {
      LOGGER.error(
          "Token could not be verified by the provided public key : " + keyLocation.getPath(), e);
    } catch (JOSEException ex) {
      LOGGER.debug("Token parsing error", ex);
    }
    return false;
  }

  private void sendInvalidTokenError(ServletResponse response) throws IOException {
    sendJsonErrorStatus(response, "Invalid token", 403);
  }

  private void sendJsonErrorStatus(ServletResponse servletResponse, String details, int httpCode)
      throws IOException {
    HttpServletResponse response = (HttpServletResponse) servletResponse;
    response.setContentType(MediaType.APPLICATION_JSON);
    response.setCharacterEncoding("UTF-8");
    UnauthorizedStatus status = new UnauthorizedStatus(details);
    String entityString = new ObjectMapper().writeValueAsString(status);
    response.getWriter().write(entityString);
    response.setStatus(httpCode);
  }
}
