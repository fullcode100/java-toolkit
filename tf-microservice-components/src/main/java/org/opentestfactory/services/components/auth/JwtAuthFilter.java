/*
 *  Copyright (c) 2020 - 2021 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.services.components.auth;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWSVerifier;
import com.nimbusds.jose.crypto.factories.DefaultJWSVerifierFactory;
import com.nimbusds.jose.proc.JWSVerifierFactory;
import com.nimbusds.jwt.SignedJWT;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.security.Key;
import java.text.ParseException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.core.MediaType;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * This filter checks if authentication is needed per the active configurfation
 * and if so, checks if the JWT auth token was sent and is valid.
 * @author edegenetais
 */
@Component
public class JwtAuthFilter implements Filter {

    private static final Logger LOGGER = LoggerFactory.getLogger(JwtAuthFilter.class);

    private AuthConfiguration cfg;

    public JwtAuthFilter(AuthConfiguration cfg) {
        this.cfg=cfg;
        LOGGER.info("JWTAuth filter created, {} mode.", cfg.anonymousAllowed() ? "test" : "secure");
    }

    @Override
    public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException {
        LoggerFactory.getLogger(JwtAuthFilter.class).debug("Applying JWT auth filter");
        HttpServletRequest req = (HttpServletRequest) arg0;
        if (cfg.anonymousAllowed() && (req.getLocalAddr().matches("127.0.0.[12]?[0-9]?[0-9]")
                || req.getLocalAddr().matches("0:0:0:0:0:0:0:[0-9a-f]+"))) {
            arg2.doFilter(arg0, arg1);
        } else {

            String header = req.getHeader("Authorization");
            if (header == null || header.trim().length() == 0) {
                sendJsonErrorStatus(arg1, "Unauthenticated", 401);
            } else {
                checkAuthorizationHeader(header, arg2, arg0, arg1);
            }

        }
    }

    private void checkAuthorizationHeader(String header, FilterChain arg2, ServletRequest arg0, ServletResponse arg1) throws IOException, ServletException {
        String[] headerParts = header.split(" ");
        if (headerParts.length == 2 && "bearer".equalsIgnoreCase(headerParts[0])) {
            
            if(isValidHeader(headerParts[1])){
                arg2.doFilter(arg0, arg1);
            }else{
                sendInvalidTokenError(arg1);
            }
            
        } else {
            sendInvalidTokenError(arg1);
        }
    }

    private boolean isValidHeader(String token) throws IOException {
        boolean valid=false;
        try{
            SignedJWT jwt=SignedJWT.parse(token);
            JWSVerifierFactory f=new DefaultJWSVerifierFactory();
            
            for(File keyLocation:cfg.trustedAutorities()){
                valid = checkTokenAgainstPublicKey(keyLocation, f, jwt, valid);
            }
        } catch (ParseException ex) {
            LOGGER.debug("Token parsing error",ex);
            valid=false;
        }
        return valid;
    }

    private boolean checkTokenAgainstPublicKey(File keyLocation, JWSVerifierFactory f, SignedJWT jwt, boolean valid) throws IOException {
        try ( FileReader fr = new FileReader(keyLocation);) {
            PEMParser pemParser = new PEMParser(fr);
            JcaPEMKeyConverter converter = new JcaPEMKeyConverter();
            SubjectPublicKeyInfo info = SubjectPublicKeyInfo.getInstance(pemParser.readObject());
            Key key = converter.getPublicKey(info);
            
            JWSVerifier v = f.createJWSVerifier(jwt.getHeader(), key);
            
            if(jwt.verify(v)){
                valid=true;
            }
        } catch (JOSEException ex) {
            LOGGER.debug("Token parsing error",ex);
        }
        return valid;
    }
    
    private void sendInvalidTokenError(ServletResponse arg1) throws IOException {
        sendJsonErrorStatus(arg1, "Invalid token", 403);
    }

    private void sendJsonErrorStatus(ServletResponse servletResponse, String details, int httpCode) throws IOException {
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        response.setContentType(MediaType.APPLICATION_JSON);
        response.setCharacterEncoding("UTF-8");
        UnauthorizedStatus status=new UnauthorizedStatus(details);
        String entityString = new ObjectMapper().writeValueAsString(status);
        response.getWriter().write(entityString);
        response.setStatus(httpCode);
    }

}
