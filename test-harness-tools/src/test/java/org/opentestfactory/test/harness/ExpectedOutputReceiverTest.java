/*
 *  Copyright (c) 2020 - 2021 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.test.harness;

import java.io.IOException;
import java.io.InputStream;
import java.time.Duration;
import java.util.Properties;
import net.javacrumbs.jsonunit.JsonAssert;
import org.apache.commons.io.IOUtils;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.mockserver.client.server.ForwardChainExpectation;
import org.mockserver.integration.ClientAndServer;
import org.mockserver.model.HttpRequest;
import org.mockserver.model.HttpResponse;
import org.mockserver.model.JsonBody;
import org.mockserver.verify.VerificationTimes;
import org.slf4j.LoggerFactory;

/** @author edegenetais */
public class ExpectedOutputReceiverTest extends AbstractTestConfigurationDependentTest {

  private ClientAndServer mockServer;
  private ExpectedOutputReceiver testee;

  @Before
  public void setUp() {
    mockServer = Mockito.mock(ClientAndServer.class);
    Mockito.when(mockServer.when(Mockito.any()))
        .thenReturn(Mockito.mock(ForwardChainExpectation.class));
    testee = new ExpectedOutputReceiver(mockServer);
  }

  @Test(expected = IllegalStateException.class)
  public void noAddedMappingfAfterAddingExpectedRequests() {
    testee
        .withExpectedRequests(HttpRequest.request().withBody("{}"))
        .withVariableMapping("key", "value");
  }

  @Test(expected = IllegalStateException.class)
  public void noAddedMappingfAfterAddingUnwantedRequests() {
    testee
        .withUnwantedRequests(HttpRequest.request().withBody("{}"))
        .withVariableMapping("key", "value");
  }

  @Test
  public void honorsMappings() throws IOException {
    JsonVariableMappings mappings =
        testee
            .withVariableMapping("key1", "value1")
            .withVariableMapping("key2", "value2")
            .mappings();
    try (InputStream inputResourceStream =
            getClass().getResourceAsStream("jsonForReceiverMappingsTest.json.in");
        InputStream expectedOutputStream =
            getClass().getResourceAsStream("expectedJsonWithReceiverMappingsTest.json"); ) {
      String actual = mappings.replaceMappings(inputResourceStream);
      String expected = IOUtils.toString(expectedOutputStream);

      JsonAssert.assertJsonEquals(expected, actual);
    }
  }

  @Test
  public void throwAssertionErrorIfExpectedRequestNotFound() throws InterruptedException {
    final String requestPath = "/destination";
    ArgumentCaptor<HttpRequest> requestCaptor = ArgumentCaptor.forClass(HttpRequest.class);

    final HttpRequest expectedRequest = mockForExpectedRequest(requestPath);

    final ForwardChainExpectation reponseObjectMock = Mockito.mock(ForwardChainExpectation.class);

    ClientAndServer mockServerMock =
        produceServerMockForExpectedRequest(reponseObjectMock, new HttpRequest[0]);

    ExpectedOutputReceiver testee =
        new ExpectedOutputReceiver(mockServerMock).withExpectedRequests(expectedRequest);

    Mockito.verify(mockServerMock, Mockito.times(1)).when(requestCaptor.capture());

    HttpRequest request = requestCaptor.getValue();
    Assert.assertEquals(requestPath, request.getPath().getValue());

    Mockito.verify(reponseObjectMock, Mockito.times(1))
        .respond(HttpResponse.response().withStatusCode(SUTSender.HTTP_OK));

    // If things work, this should trigger the expected exception HERE
    boolean gotTheFailure = false;
    try {
      testee.waitAndVerifyExpectedCall(Duration.ZERO);
    } catch (AssertionError e) {
      gotTheFailure = true;
      LoggerFactory.getLogger(ExpectedOutputReceiverTest.class)
          .info("Got the expected AssertionError");
    }
    Assert.assertTrue(
        "Didn't get the expected assertion error, with no request registered.", gotTheFailure);
  }

  @Test
  public void beHappyIfExpectedRequestFound() throws InterruptedException {
    final String requestPath = "/destination";
    ArgumentCaptor<HttpRequest> requestCaptor = ArgumentCaptor.forClass(HttpRequest.class);

    final HttpRequest expectedRequest = mockForExpectedRequest(requestPath);

    final ForwardChainExpectation reponseObjectMock = Mockito.mock(ForwardChainExpectation.class);

    ClientAndServer mockServerMock =
        produceServerMockForExpectedRequest(reponseObjectMock, new HttpRequest[] {expectedRequest});

    ExpectedOutputReceiver testee =
        new ExpectedOutputReceiver(mockServerMock).withExpectedRequests(expectedRequest);

    Mockito.verify(mockServerMock, Mockito.times(1)).when(requestCaptor.capture());

    HttpRequest request = requestCaptor.getValue();
    Assert.assertEquals(requestPath, request.getPath().getValue());

    Mockito.verify(reponseObjectMock, Mockito.times(1))
        .respond(HttpResponse.response().withStatusCode(SUTSender.HTTP_OK));

    // This should NOT trigger AssertionError
    testee.waitAndVerifyExpectedCall(Duration.ZERO);
  }

  @Test
  public void beHappyWithOtherArrayOrderIfExpectedRequestRegardlessOfArrayOrder()
      throws InterruptedException {
    final String requestPath = "/destination";
    ArgumentCaptor<HttpRequest> requestCaptor = ArgumentCaptor.forClass(HttpRequest.class);

    final HttpRequest expectedRequest = mockForRequest(requestPath, "{\"unorderedArray\": [1,5]}");
    final HttpRequest actualRequest = mockForRequest(requestPath, "{\"unorderedArray\": [5,1]}");

    final ForwardChainExpectation reponseObjectMock = Mockito.mock(ForwardChainExpectation.class);

    ClientAndServer mockServerMock =
        produceServerMockForExpectedRequest(reponseObjectMock, new HttpRequest[] {actualRequest});

    ExpectedOutputReceiver testee =
        new ExpectedOutputReceiver(mockServerMock)
            .withExpectedRequests(expectedRequest)
            .withIgnoreArrayElementOrder();

    Mockito.verify(mockServerMock, Mockito.times(1)).when(requestCaptor.capture());

    HttpRequest request = requestCaptor.getValue();
    Assert.assertEquals(requestPath, request.getPath().getValue());

    Mockito.verify(reponseObjectMock, Mockito.times(1))
        .respond(HttpResponse.response().withStatusCode(SUTSender.HTTP_OK));

    // This should NOT trigger AssertionError
    testee.waitAndVerifyExpectedCall(Duration.ZERO);
  }

  @Test
  public void doCheckArrayOrderIfExpectedTo() throws InterruptedException {
    final String requestPath = "/destination";
    ArgumentCaptor<HttpRequest> requestCaptor = ArgumentCaptor.forClass(HttpRequest.class);

    final HttpRequest expectedRequest = mockForRequest(requestPath, "{\"unorderedArray\": [1,5]}");
    final HttpRequest actualRequest = mockForRequest(requestPath, "{\"unorderedArray\": [5,1]}");

    final ForwardChainExpectation reponseObjectMock = Mockito.mock(ForwardChainExpectation.class);

    ClientAndServer mockServerMock =
        produceServerMockForExpectedRequest(reponseObjectMock, new HttpRequest[] {actualRequest});

    ExpectedOutputReceiver testee =
        new ExpectedOutputReceiver(mockServerMock).withExpectedRequests(expectedRequest);

    Mockito.verify(mockServerMock, Mockito.times(1)).when(requestCaptor.capture());

    HttpRequest request = requestCaptor.getValue();
    Assert.assertEquals(requestPath, request.getPath().getValue());

    Mockito.verify(reponseObjectMock, Mockito.times(1))
        .respond(HttpResponse.response().withStatusCode(SUTSender.HTTP_OK));

    // If things work, this should trigger the expected exception HERE
    boolean gotTheFailure = false;
    try {
      testee.waitAndVerifyExpectedCall(Duration.ZERO);
    } catch (AssertionError e) {
      gotTheFailure = true;
      LoggerFactory.getLogger(ExpectedOutputReceiverTest.class)
          .info("Got the expected AssertionError");
    }
    Assert.assertTrue(
        "Didn't get the expected assertion error, with differently ordered array elements, while"
            + " list order was not supposed to be ignored.",
        gotTheFailure);
  }

  @Test
  public void yelpIfMissingElementInArrayRegardlessOfArrayOrder() throws InterruptedException {
    final String requestPath = "/destination";
    ArgumentCaptor<HttpRequest> requestCaptor = ArgumentCaptor.forClass(HttpRequest.class);

    final HttpRequest expectedRequest =
        mockForRequest(requestPath, "{\"unorderedArray\": [1,3,5]}");
    final HttpRequest actualRequest = mockForRequest(requestPath, "{\"unorderedArray\": [5,1]}");

    final ForwardChainExpectation reponseObjectMock = Mockito.mock(ForwardChainExpectation.class);

    ClientAndServer mockServerMock =
        produceServerMockForExpectedRequest(reponseObjectMock, new HttpRequest[] {actualRequest});

    ExpectedOutputReceiver testee =
        new ExpectedOutputReceiver(mockServerMock)
            .withExpectedRequests(expectedRequest)
            .withIgnoreArrayElementOrder();

    Mockito.verify(mockServerMock, Mockito.times(1)).when(requestCaptor.capture());

    HttpRequest request = requestCaptor.getValue();
    Assert.assertEquals(requestPath, request.getPath().getValue());

    Mockito.verify(reponseObjectMock, Mockito.times(1))
        .respond(HttpResponse.response().withStatusCode(SUTSender.HTTP_OK));

    // If things work, this should trigger the expected exception HERE
    boolean gotTheFailure = false;
    try {
      testee.waitAndVerifyExpectedCall(Duration.ZERO);
    } catch (AssertionError e) {
      gotTheFailure = true;
      LoggerFactory.getLogger(ExpectedOutputReceiverTest.class)
          .info("Got the expected AssertionError");
    }
    Assert.assertTrue(
        "Didn't get the expected assertion error with missing expected array element.",
        gotTheFailure);
  }

  @Test
  public void shouldCheckForUnwantedIfAny() throws InterruptedException {
    String requestPath = "/destination";
    ClientAndServer mockServerMock = produceServerMockWithUnwantedRequest();
    final HttpRequest expectedRequest = mockForExpectedRequest(requestPath);

    ExpectedOutputReceiver testee =
        new ExpectedOutputReceiver(mockServerMock).withUnwantedRequests(expectedRequest);

    // If things work, this should trigger the expected exception HERE
    boolean receiverHasThrown;
    try {
      testee.waitAndVerifyExpectedCall(Duration.ZERO);
      receiverHasThrown = false;
    } catch (AssertionError e) {
      receiverHasThrown = true;
      LoggerFactory.getLogger(ExpectedOutputReceiverTest.class)
          .info("Got the expected AssertionError");
    }
    Assert.assertTrue(
        "Didn't get the expected assertion error, with no request registered.", receiverHasThrown);
  }

  private ClientAndServer produceServerMockWithUnwantedRequest() {
    final ClientAndServer mockServerMock = Mockito.mock(ClientAndServer.class);
    Mockito.when(
            mockServerMock.verify(
                Mockito.isA(HttpRequest.class), Mockito.eq(VerificationTimes.exactly(0))))
        .thenThrow(new AssertionError("UnwantedRequestMock"));

    return mockServerMock;
  }

  private ClientAndServer produceServerMockForExpectedRequest(
      final ForwardChainExpectation reponseObjectMock, HttpRequest[] registeredRequestToRespond) {
    final ClientAndServer mockServerMock = Mockito.mock(ClientAndServer.class);
    Mockito.when(mockServerMock.when(Mockito.isA(HttpRequest.class))).thenReturn(reponseObjectMock);
    Mockito.when(mockServerMock.retrieveRecordedRequests(Mockito.any()))
        .thenReturn(registeredRequestToRespond);
    return mockServerMock;
  }

  private org.mockserver.model.HttpRequest mockForExpectedRequest(final String requestPath) {
    return mockForRequest(requestPath, "{\"attribute\":\"value\"}");
  }

  private HttpRequest mockForRequest(final String requestPath, final String attributevalue) {
    return HttpRequest.request().withPath(requestPath).withBody(JsonBody.json(attributevalue));
  }

  @Override
  protected void setDefaultPropertiesUp(Properties prop) {
    /*No default prop needed*/
  }
}
