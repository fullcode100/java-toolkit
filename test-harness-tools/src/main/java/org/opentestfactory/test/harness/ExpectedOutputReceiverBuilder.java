/*
 *  Copyright (c) 2020 - 2023 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.test.harness;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.List;
import org.apache.commons.io.IOUtils;
import org.mockserver.integration.ClientAndServer;
import org.mockserver.matchers.MatchType;
import org.mockserver.model.HttpRequest;
import org.mockserver.model.HttpResponse;
import org.mockserver.model.JsonBody;
import org.mockserver.model.NottableString;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ExpectedOutputReceiverBuilder {
  private static final Logger LOGGER = LoggerFactory.getLogger(ExpectedOutputReceiverBuilder.class);
  private final ClientAndServer mockServer;
  private final List<HttpRequest> expectedRequests;
  private final List<HttpRequest> unwantedRequests;
  private JsonVariableMappings variableMappings;
  private boolean ignoreArrayOrder;

  private ExpectedOutputReceiverBuilder(ClientAndServer mockServer) {
    this.mockServer = mockServer;
    expectedRequests = new ArrayList<>();
    unwantedRequests = new ArrayList<>();
    variableMappings = JsonVariableMappings.noMappings();
    ignoreArrayOrder = false;
  }

  public static ExpectedOutputReceiverBuilder withMock(ClientAndServer mockServer) {
    return new ExpectedOutputReceiverBuilder(mockServer);
  }

  public ExpectedOutputReceiverBuilder withVariableMapping(String key, String value) {
    throwExceptionIfRequestsAreAlreadySet();
    this.variableMappings = variableMappings.withAdditionalStringMapping(key, value);
    return this;
  }

  public ExpectedOutputReceiverBuilder withExpectedRequests(HttpRequest... expectedRequests) {
    List<HttpRequest> expectedRequestList = List.of(expectedRequests);
    expectedRequestList.forEach(
        expectedRequest -> {
          warnIfAnyStrayVariableConstructOccurrences(expectedRequest);
          specifyOkResponseForRequestPath(expectedRequest.getPath());
        });
    this.expectedRequests.addAll(expectedRequestList);
    return this;
  }

  public ExpectedOutputReceiverBuilder withExpectedRequestTemplate(
      String path, InputStream bodyStream) throws IOException {
    String body = variableMappings.replaceMappings(bodyStream);
    specifyOkResponseForRequestPath(path);
    HttpRequest newRequest =
        HttpRequest.request()
            .withPath(path)
            .withBody(JsonBody.json(body, MatchType.ONLY_MATCHING_FIELDS));
    this.expectedRequests.add(newRequest);
    return this;
  }

  public ExpectedOutputReceiverBuilder withUnwantedRequests(HttpRequest... unwantedRequests) {
    List<HttpRequest> unwantedRequestList = List.of(unwantedRequests);
    this.unwantedRequests.addAll(unwantedRequestList);
    return this;
  }

  public ExpectedOutputReceiverBuilder withIgnoreArrayElementOrder() {
    this.ignoreArrayOrder = true;
    return this;
  }

  /**
   * Tells the mockserver to serve said resource. A mapping will be added for envelope substitution
   * (the mapping key will be base on the resource name with slashes replaced by underscores, the
   * value the exposed URL).
   *
   * @param attachmentResourceName the resource name. If this matchs no known resource, an {@link
   *     UnknownTestResource} exception will be thrown.
   * @throws IOException if resource access fails (may happen)
   * @throws URISyntaxException if the computed attachemnt URI is invalid (should NEVER happen)
   * @return the new receiver with a mapping for the resource URL.
   */
  public ExpectedOutputReceiverBuilder withMockAttachment(String attachmentResourceName)
      throws IOException, URISyntaxException {
    try (InputStream attachmentStream = getClass().getResourceAsStream(attachmentResourceName)) {
      if (attachmentStream == null) {
        throw new UnknownTestResource("Resource not found: " + attachmentResourceName);
      }
      URI mockAttachmentURI =
          new URI(
              "http",
              null,
              TestConfiguration.values().getMockHost(),
              this.mockServer.getPort(),
              attachmentResourceName,
              null,
              null);
      mockServer
          .when(HttpRequest.request(attachmentResourceName))
          .respond(
              HttpResponse.response()
                  .withStatusCode(200)
                  .withBody(IOUtils.toByteArray(attachmentStream)));
      return this.withVariableMapping(
          attachmentResourceName.replace('/', '_'), mockAttachmentURI.toString());
    }
  }

  public ExpectedOutputReceiver build() {
    return new ExpectedOutputReceiver(this);
  }

  private void warnIfAnyStrayVariableConstructOccurrences(HttpRequest request) {
    String expectedPayload = request.getBodyAsString();
    List<String> strayVariables =
        JsonVariableMappings.searchForStrayVariableConstructs(expectedPayload);
    strayVariables.forEach(
        strayVariable ->
            LOGGER.warn(
                "Found not replaced variable construct {} in {}", strayVariable, expectedPayload));
  }

  private void specifyOkResponseForRequestPath(NottableString expectedRequestPath) {
    mockServer
        .when(HttpRequest.request().withPath(expectedRequestPath))
        .respond(HttpResponse.response().withStatusCode(SUTSender.HTTP_OK));
  }

  private void specifyOkResponseForRequestPath(String expectedRequestPath) {
    mockServer
        .when(HttpRequest.request().withPath(expectedRequestPath))
        .respond(HttpResponse.response().withStatusCode(SUTSender.HTTP_OK));
  }

  private void throwExceptionIfRequestsAreAlreadySet() {
    if (expectedOrUnwantedRequestsAreAlreadySet()) {
      throw new IllegalStateException(
          "Adding variables after adding expected requests is not supported");
    }
  }

  private boolean expectedOrUnwantedRequestsAreAlreadySet() {
    return !expectedRequests.isEmpty() || !unwantedRequests.isEmpty();
  }

  public ClientAndServer getMockServer() {
    return mockServer;
  }

  public List<HttpRequest> getExpectedRequests() {
    return expectedRequests;
  }

  public List<HttpRequest> getUnwantedRequests() {
    return unwantedRequests;
  }

  public JsonVariableMappings getVariableMappings() {
    return variableMappings;
  }

  public boolean isIgnoreArrayOrder() {
    return ignoreArrayOrder;
  }
}
