/*
 *  Copyright (c) 2020 - 2022 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.test.harness;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.io.IOUtils;

/**
 * Very simple key-value templating system. Should this get more complicated, we should look for a
 * suitable templating library before making this one more sophisticated.
 */
public class JsonVariableMappings {
  public static final String UNIX_EOL_NEXT_PATTERN = ",\n";
  public static final String WINDOWS_EOL_NEXT_PATTERN = ",\r\n";
  public static final String UNIX_EOL_NEXT_REPLACEMENT = ",\n";
  public static final String WINDOWS_EOL_NEXT_REPLACEMENT = ",\r\n";
  public static final String UNIX_EOL_NONEXT_REPLACEMENT = "\n";
  public static final String WINDOWS_EOL_NONEXT_REPLACEMENT = "\r\n";
  public static final String UNIX_EOL_NONEXT_PATTERN = "\n";
  public static final String WINDOWS_EOL_NONEXT_PATTERN = "\r\n";
  public static final int BASE_DIX = 10;
  public static final String UNIX_COMMA_EOL = ",\n";
  public static final String WINDOWS_COMMA_EOL = ",\r\n";
  private Map<String, String> mappings;

  public JsonVariableMappings(Map<String, String> mappings) {
    this.mappings = Objects.requireNonNull(mappings, "Mappings should not be null");
  }

  public static JsonVariableMappings noMappings() {
    return new JsonVariableMappings(Collections.emptyMap());
  }

  public static JsonVariableMappings withStringMapping(String key, String value) {
    return noMappings().withAdditionalStringMapping(key, value);
  }

  public static JsonVariableMappings withIntegerMapping(String key, Integer value) {
    return noMappings().withAdditionalIntegerMapping(key, value);
  }

  public static List<String> searchForStrayVariableConstructs(String expectedPayload) {
    Pattern variablePattern = Pattern.compile(": *#\\{[^}]*\\},?\r?\n");
    Matcher variableMatcher = variablePattern.matcher(expectedPayload);
    List<String> occurrences = new ArrayList<>();

    while (variableMatcher.find()) {
      occurrences.add(
          variableMatcher
              .group()
              .replace(WINDOWS_EOL_NEXT_PATTERN, "")
              .replace(WINDOWS_EOL_NONEXT_PATTERN, "")
              .replace(UNIX_EOL_NEXT_PATTERN, "")
              .replace(UNIX_EOL_NONEXT_PATTERN, ""));
    }
    return occurrences;
  }

  public JsonVariableMappings withAdditionalStringMapping(String key, String value) {
    Map<String, String> newMappings = new HashMap<>(this.mappings);
    newMappings.put(key, "\"" + value + "\"");
    return new JsonVariableMappings(newMappings);
  }

  public JsonVariableMappings withAdditionalIntegerMapping(String key, int value) {
    Map<String, String> newMappings = new HashMap<>(this.mappings);
    newMappings.put(key, Integer.toString(value, BASE_DIX));
    return new JsonVariableMappings(newMappings);
  }

  public String replaceMappings(InputStream bodyStream) throws IOException {

    String bodyString = IOUtils.toString(bodyStream, "UTF-8");
    return replaceMappings(bodyString);
  }

  public String replaceMappings(String bodyString) {
    for (Map.Entry<String, String> variableMapping : mappings.entrySet()) {
      String construct = ": *#\\{" + variableMapping.getKey() + "\\}";
      bodyString =
          bodyString.replaceAll(
              construct + UNIX_EOL_NEXT_PATTERN,
              ": " + variableMapping.getValue() + UNIX_EOL_NEXT_REPLACEMENT);
      bodyString =
          bodyString.replaceAll(
              construct + WINDOWS_EOL_NEXT_PATTERN,
              ": " + variableMapping.getValue() + WINDOWS_EOL_NEXT_REPLACEMENT);
      bodyString =
          bodyString.replaceAll(
              construct + UNIX_EOL_NONEXT_PATTERN,
              ": " + variableMapping.getValue() + UNIX_EOL_NONEXT_REPLACEMENT);
      bodyString =
          bodyString.replaceAll(
              construct + WINDOWS_EOL_NONEXT_PATTERN,
              ": " + variableMapping.getValue() + WINDOWS_EOL_NONEXT_REPLACEMENT);

      String listElementConstruct =
          ": *\\[(.*,)* *(?<construct>#\\{" + variableMapping.getKey() + "})(,[^\\[]+)*\\]";
      Pattern listElementPattern = Pattern.compile(listElementConstruct);
      Matcher m = listElementPattern.matcher(bodyString);
      while (m.find()) {
        bodyString =
            bodyString.substring(0, m.start("construct"))
                + variableMapping.getValue()
                + bodyString.substring(m.end("construct"));
        m = listElementPattern.matcher(bodyString);
      }
    }
    return bodyString;
  }
}
