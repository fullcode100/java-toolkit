/*
 *  Copyright (c) 2020 - 2022 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.test.harness;

import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import org.apache.commons.io.IOUtils;
import org.apache.http.Header;
import org.apache.http.client.fluent.Request;
import org.apache.http.client.fluent.Response;
import org.apache.http.message.BasicHeader;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.mockserver.integration.ClientAndServer;
import org.mockserver.matchers.MatchType;
import org.mockserver.model.HttpRequest;
import org.mockserver.model.JsonBody;
import org.slf4j.LoggerFactory;

/**
 * This class offers base micro service test primitives. It also automatically starts the mock
 * before each test, and stops it after each test.
 */
public abstract class AbstractMicroServiceTestBase {
  public static final Duration DELAY_BEFORE_ASYNC_REQUEST_VERIFY = Duration.ofMillis(1000);
  public static final Duration DELAY_BEFORE_ASYNC_REQUEST_SEQUENCE_VERIFY = Duration.ofMillis(1000);
  public static final Duration DELAY_FOR_SSH = Duration.ofSeconds(45);

  protected static final String AUTH_TOKEN_KEY_SUFFIX = ".auth-token";
  protected static final String URL_KEY_SUFFIX = ".url";

  public static final String EVENTBUS_BASE_KEY = "eventbus.base";
  private static final String EVENTBUS_URL_KEY = EVENTBUS_BASE_KEY + URL_KEY_SUFFIX;
  private static final String EVENT_BUS_AUTH_TOKEN_KEY = EVENTBUS_BASE_KEY + AUTH_TOKEN_KEY_SUFFIX;
  public static final String SUBSCRIPTIONS_PATH = "/subscriptions";

  private static final MockServerHelper MOCK_SERVER_HELPER =
      new MockServerHelper(Duration.ofMillis(100), Duration.ofMinutes(1));
  private static final String MOCK_HOST_NAME = TestConfiguration.values().getMockHost();
  private static final String RECEIVER_INBOX_MAPPING_KEY = "receiverInbox";

  public final URL BUS_BASE_URL;
  public final AuthToken BUS_AUTH_TOKEN;
  public final AuthToken serviceAuthToken;

  private final int receiverPort;
  private final URL sutBaseUrl;

  protected ClientAndServer mockServer;

  /**
   * @param receiverPort TCP port on which the test receiver will listen to expected (or unwanted)
   *     messages. Try to use different ones across tests, to isolate tests and make results easier
   *     to read.
   * @param sutBaseUrl base URL from which the system under test will receive test inputs.
   */
  public AbstractMicroServiceTestBase(
      int receiverPort, URL sutBaseUrl, AuthToken serviceAuthToken) {
    this.receiverPort = receiverPort;
    this.sutBaseUrl = sutBaseUrl;
    final TestConfiguration configuration = TestConfiguration.values();
    this.BUS_BASE_URL = configuration.getServiceBaseURL(EVENTBUS_URL_KEY);
    this.BUS_AUTH_TOKEN = configuration.getServiceAuthToken(EVENT_BUS_AUTH_TOKEN_KEY);
    this.serviceAuthToken = serviceAuthToken;
  }

  @BeforeClass
  public static void mockServerWarmUp() throws InterruptedException {
    MOCK_SERVER_HELPER.cleanStop(ClientAndServer.startClientAndServer(1088));
  }

  @Before
  public void startClientAndServer() throws InterruptedException {
    mockServer = ClientAndServer.startClientAndServer(receiverPort);
    MOCK_SERVER_HELPER.waitForStart(mockServer);
  }

  @After
  public void stopClientAndServer() throws InterruptedException {
    MOCK_SERVER_HELPER.cleanStop(mockServer);
  }

  /**
   * Send a test input message built from template to the SUT bus.
   *
   * @param testMessageResourceName the template with value placeholders as defined by {@link
   *     JsonVariableMappings}.
   * @param variableMappings the mappings to apply.
   * @return SUTSender object to test response code.
   * @throws URISyntaxException
   * @throws IOException
   */
  protected SUTSender sendTemplatedTestMessage(
      String testMessageResourceName, JsonVariableMappings variableMappings)
      throws URISyntaxException, IOException {
    return jsonRESTPost(
        testMessageResourceName, getSutURI(), variableMappings, this.serviceAuthToken);
  }

  /**
   * Send a test input message to the SUT bus.
   *
   * @param testMessageResourceName message content to send.
   * @return reference to the SUTSender object for further actions like checking HTTP return codes.
   * @throws IOException
   * @throws URISyntaxException
   */
  protected SUTSender sendTestMessage(String testMessageResourceName)
      throws IOException, URISyntaxException {
    return jsonRESTPost(
        testMessageResourceName,
        getSutURI(),
        JsonVariableMappings.noMappings(),
        this.serviceAuthToken);
  }

  private URI getSutURI() throws URISyntaxException {
    return new URI(BUS_BASE_URL + "/publications");
  }

  /**
   * Send a JSON test input message to the SUT.
   *
   * @param testMessageResourceName message content to send
   * @param sutURI URI of the destination endpoint
   * @param variableMappings
   * @return reference to the SUTSender object for further actions like checking HTTP return codes.
   * @throws IOException
   */
  protected SUTSender jsonRESTPost(
      String testMessageResourceName,
      URI sutURI,
      JsonVariableMappings variableMappings,
      AuthToken sutAuthToken)
      throws IOException {
    Request request =
        Request.Post(sutURI)
            .addHeader(ContentType.JSON.header)
            .bodyStream(useTestResource(testMessageResourceName, variableMappings));
    Response execute = sutAuthToken.apply(request).execute();
    return new SUTSender(execute);
  }

  /**
   * Build a request matcher for the {@link ExpectedOutputReceiver} instance.
   *
   * @param pathOfMock
   * @param expectedPayloadName
   * @return
   * @throws IOException
   */
  protected HttpRequest requestMatcher(String pathOfMock, String expectedPayloadName)
      throws IOException {
    String expected = IOUtils.toString(useTestResource(expectedPayloadName));

    return HttpRequest.request()
        .withPath(pathOfMock)
        .withBody(JsonBody.json(expected, MatchType.ONLY_MATCHING_FIELDS));
  }

  protected InputStream useTestResource(String resourceName) {
    try {
      return useTestResource(resourceName, JsonVariableMappings.noMappings());
    } catch (IOException e) {
      throw new RuntimeException("Failed to read from resource. This should not happen.", e);
    }
  }

  /**
   * Get an input stream on a test resource (checks that the resource exists)
   *
   * @param testResourceName name of the test resource. Absolute names are advised.
   * @return an input stream for resource contents.
   */
  private InputStream useTestResource(
      String testResourceName, JsonVariableMappings variableMappings) throws IOException {
    if (Objects.requireNonNullElse(testResourceName, "").isBlank()) {
      throw new UnknownTestResource("Cannot use a resource from a null or blank name.");
    }
    InputStream resourceAsStream = getClass().getResourceAsStream(testResourceName);
    if (resourceAsStream == null) {
      throw new UnknownTestResource("Test resource " + testResourceName + " not found.");
    }
    String resourceContent = IOUtils.toString(resourceAsStream, "UTF-8");
    String replacedContent = variableMappings.replaceMappings(resourceContent);

    warnForStrayVariableMappingPatterns(testResourceName, replacedContent);

    return new ByteArrayInputStream(replacedContent.getBytes("UTF-8"));
  }

  private void warnForStrayVariableMappingPatterns(
      String testResourceName, String replacedContent) {
    List<String> strayPatterns =
        JsonVariableMappings.searchForStrayVariableConstructs(replacedContent);

    strayPatterns.stream()
        .forEach(
            pattern -> {
              LoggerFactory.getLogger(AbstractMicroServiceTestBase.class)
                  .warn(
                      "Found stray variable injection pattern {} in replaced payload {}.",
                      pattern,
                      testResourceName);
            });
  }

  /**
   * Create an {@link ExpectedOutputReceiver} instance with the base setup from this test class.
   *
   * @return
   */
  protected ExpectedOutputReceiver getExpectedOutputReceiver() {
    return ExpectedOutputReceiver.basedOnMock(mockServer);
  }

  /**
   * Post a JSON test input to the specified endpoint.
   *
   * @param messageName name of the test resource to send, as for {@link #useTestResource(String)}
   * @param sutEndpointPath end point to post the json to.
   * @return reference to the {@link SUTSender} object for further actions like checking HTTP return
   *     codes.
   * @throws URISyntaxException
   * @throws IOException
   */
  protected SUTSender postJSONToSUTendPoint(
      String messageName, String sutEndpointPath, JsonVariableMappings variables)
      throws URISyntaxException, IOException {
    return postToSUTendPoint(messageName, sutEndpointPath, variables, ContentType.JSON);
  }

  /**
   * Post a YAML test input to the specified endpoint.
   *
   * @param messageName name of the test resource to send, as for {@link #useTestResource(String)}
   * @param sutEndpointPath end point to post the json to.
   * @return reference to the {@link SUTSender} object for further actions like checking HTTP return
   *     codes.
   * @throws URISyntaxException
   * @throws IOException
   */
  protected SUTSender postYAMLToSUTendPoint(String messageName, String sutEndpointPath)
      throws URISyntaxException, IOException {
    return postToSUTendPoint(
        messageName, sutEndpointPath, JsonVariableMappings.noMappings(), ContentType.YAML);
  }

  private SUTSender postToSUTendPoint(
      String payloadMessageName,
      String sutEndpointPath,
      JsonVariableMappings variables,
      ContentType contentType)
      throws URISyntaxException, IOException {

    URI targetURI = new URI(sutBaseUrl.toExternalForm() + sutEndpointPath);
    String payloadStringContent = variables.replaceMappings(useTestResource(payloadMessageName));

    Request request =
        Request.Post(targetURI)
            .setHeader(contentType.header)
            .bodyByteArray(payloadStringContent.getBytes(SUTSender.DEFAULT_ENCODING));

    Response sutResponse = this.serviceAuthToken.apply(request).execute();

    return new SUTSender(sutResponse);
  }

  protected JsonVariableMappings subscriptionMappings(String subscriptionName) throws IOException {
    String receiverInbox =
        new URL(
                "http://"
                    + MOCK_HOST_NAME
                    + ":"
                    + receiverPort
                    + subscriptionPath(subscriptionName))
            .toExternalForm();
    return JsonVariableMappings.noMappings()
        .withAdditionalStringMapping(RECEIVER_INBOX_MAPPING_KEY, receiverInbox);
  }

  protected String subscriptionPath(String subscriptionName) throws IOException {
    InputStream subscriptionPayloadStream = useTestResource(subscriptionName);
    String subscriptionPayload =
        JsonVariableMappings.noMappings().replaceMappings(subscriptionPayloadStream);
    if (JsonVariableMappings.searchForStrayVariableConstructs(subscriptionPayload)
            .indexOf(":#{" + RECEIVER_INBOX_MAPPING_KEY + "}")
        < 0) {
      Map<String, Object> subscription =
          new ObjectMapper().readValue(subscriptionPayload, Map.class);
      final String endpointURL =
          ((Map<String, Map<String, String>>) subscription.get("spec"))
              .get("subscriber")
              .get("endpoint");
      return new URL(endpointURL).getPath();
    } else {
      return ("/" + subscriptionName).replace("//", "/");
    }
  }

  /**
   * It so happens that YAML is not a supported content type for org.apache.http.entity.ContentType
   * so we need to have our content type model here :/
   */
  protected enum ContentType {
    JSON("application/json"),
    YAML("application/x-yaml");
    public final Header header;

    ContentType(String headerValue) {
      this.header = new BasicHeader("Content-Type", headerValue);
    }
  };
}
