/*
 *  Copyright (c) 2020 - 2023 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.test.harness;

import java.time.Duration;
import java.util.List;
import net.javacrumbs.jsonunit.ConfigurableJsonMatcher;
import net.javacrumbs.jsonunit.JsonMatchers;
import net.javacrumbs.jsonunit.core.Option;
import org.mockserver.integration.ClientAndServer;
import org.mockserver.model.HttpRequest;
import org.mockserver.model.NottableString;
import org.mockserver.verify.VerificationTimes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class may be used to define expectations on output messages from a given service. When
 * expectations are set up, call the system under test THEN call {@link
 * #waitAndVerifyExpectedCall(Duration)} on your {@link ExpectedOutputReceiver } instance to check
 * if the expected messages where received (and optionally, check that no unwanted message was
 * received).
 */
public class ExpectedOutputReceiver {
  private static final Logger LOGGER = LoggerFactory.getLogger(ExpectedOutputReceiver.class);

  private static final long DEFAULT_CHECKING_INTERVAL_IN_MILLISECONDS = 5000L;
  private static final boolean ALL_REQUESTS_ARE_RECEIVED = true;
  private static final boolean NOT_ALL_REQUESTS_ARE_RECEIVED = false;

  private final ClientAndServer mockServer;
  // receiver will verify that it got each request at least once after the wait delay
  private final List<HttpRequest> expectedRequests;
  // receiver will verify that NONE of these requests was sent after the wait delay
  private final List<HttpRequest> unwantedRequests;
  // describing key-value variable mappings to replace in JSON request templates
  private final JsonVariableMappings variableMappings;
  private final boolean ignoreArrayOrder;
  private final int speedFactor;

  public ExpectedOutputReceiver(ExpectedOutputReceiverBuilder builder) {
    this.mockServer = builder.getMockServer();
    this.expectedRequests = builder.getExpectedRequests();
    this.unwantedRequests = builder.getUnwantedRequests();
    this.variableMappings = builder.getVariableMappings();
    this.ignoreArrayOrder = builder.isIgnoreArrayOrder();
    this.speedFactor = TestConfiguration.values().getDurationFactorPercent();
  }

  /**
   * Wait some time to give time for callbacks, then verify if expected requests were received, and
   * check that no unwanted request came.
   *
   * @param delay the base delay. A duration factor is applied based on {@link
   *     TestConfiguration#getDurationFactorPercent()}.
   * @throws InterruptedException
   * @see TestConfiguration#getDurationFactorPercent()
   */
  public boolean waitAndVerifyExpectedCall(Duration delay) throws InterruptedException {
    return waitAndVerifyExpectedCall(
        delay, Duration.ofMillis(DEFAULT_CHECKING_INTERVAL_IN_MILLISECONDS));
  }

  public boolean waitAndVerifyExpectedCall(Duration delay, Duration checkingDelay)
      throws InterruptedException {
    final long timeout = delay.multipliedBy(this.speedFactor).dividedBy(100).toMillis();
    final long checkingPeriod = Math.min(checkingDelay.toMillis(), timeout);
    LOGGER.info(
        "This test specifies a {} ms delay, with factor {}%, we'll wait {} ms.",
        delay.toMillis(), speedFactor, timeout);
    if (unwantedRequests.isEmpty()) {
      LOGGER.info("Checking requests every {} ms.", checkingPeriod);
      if (checkExpectedRequestsAtRegularInterval(timeout, checkingPeriod)) {
        return ALL_REQUESTS_ARE_RECEIVED;
      }
      LOGGER.info("Timeout reached, verifying retrieved requests for the last time.");
    } else {
      Thread.sleep(timeout);
      LOGGER.info("Timeout reached, verifying retrieved requests.");
    }
    verifyNoUnwantedRequestWasReceivedOrThrowError();
    checkAllExpectedRequestsWereReceivedOrThrowError();
    return true;
  }

  private boolean checkExpectedRequestsAtRegularInterval(long timeout, long checkingPeriod)
      throws InterruptedException {
    long startTime = System.currentTimeMillis();
    while (timeoutNotReached(timeout, startTime)) {
      Thread.sleep(checkingPeriod);
      if (allExpectedRequestsWereReceived()) {
        LOGGER.info("All expected requests collected before timeout.");
        return ALL_REQUESTS_ARE_RECEIVED;
      }
    }
    return NOT_ALL_REQUESTS_ARE_RECEIVED;
  }

  private boolean timeoutNotReached(long timeout, long startTime) {
    return System.currentTimeMillis() - startTime < timeout;
  }

  private void verifyNoUnwantedRequestWasReceivedOrThrowError() {
    try {
      for (HttpRequest unwantedRequest : unwantedRequests) {
        mockServer.verify(unwantedRequest, VerificationTimes.exactly(0));
      }
    } catch (AssertionError error) {
      throw new AssertionError("Unwanted request received", error);
    }
  }

  private boolean allExpectedRequestsWereReceived() {
    boolean allExpectedRequestsReceived = true;
    for (HttpRequest expectedRequest : expectedRequests) {
      LOGGER.info("Checking for target request: {}", expectedRequest);
      allExpectedRequestsReceived &=
          isExpectedRequestFoundWithOptionalPayloadAppender(expectedRequest, null);
    }
    return allExpectedRequestsReceived;
  }

  private boolean isExpectedRequestFoundWithOptionalPayloadAppender(
      HttpRequest expectedRequest, StringBuilder stringBuilder) {
    boolean requestFound = false;
    String expectedPayload = expectedRequest.getBodyAsString();
    NottableString path = expectedRequest.getPath();
    for (HttpRequest retrievedRequest :
        mockServer.retrieveRecordedRequests(HttpRequest.request().withPath(path))) {
      LOGGER.info("Went through request: {}", retrievedRequest);
      String actualPayload = retrievedRequest.getBodyAsString();
      ConfigurableJsonMatcher<Object> expectedPayloadMatcher = buildJsonMatcher(expectedPayload);
      requestFound |= expectedPayloadMatcher.matches(actualPayload);
      if (stringBuilder != null && !requestFound) {
        stringBuilder.append(actualPayload).append("\n");
      }
    }
    return requestFound;
  }

  private ConfigurableJsonMatcher<Object> buildJsonMatcher(String expectedPayload) {
    ConfigurableJsonMatcher<Object> matcher = JsonMatchers.jsonEquals(expectedPayload);
    if (ignoreArrayOrder) {
      matcher = matcher.when(Option.IGNORING_ARRAY_ORDER);
    }
    return matcher;
  }

  private void checkAllExpectedRequestsWereReceivedOrThrowError() {
    for (HttpRequest expectedRequest : expectedRequests) {
      LOGGER.info("Checking for target request: {}", expectedRequest);
      checkExpectedRequestWasReceivedOrThrowError(expectedRequest);
    }
  }

  private void checkExpectedRequestWasReceivedOrThrowError(HttpRequest expectedRequest) {
    StringBuilder actualBuilder = new StringBuilder();
    boolean foundExpectedRequest =
        isExpectedRequestFoundWithOptionalPayloadAppender(expectedRequest, actualBuilder);
    if (!foundExpectedRequest) {
      throw new AssertionError(
          "Expected request payload not found : expected<"
              + expectedRequest.getBodyAsString()
              + "> but was <"
              + actualBuilder
              + ">");
    }
  }

  public JsonVariableMappings mappings() {
    return this.variableMappings;
  }
}
