/*
 *  Copyright (c) 2020 - 2021 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.test.harness;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import net.javacrumbs.jsonunit.ConfigurableJsonMatcher;
import net.javacrumbs.jsonunit.JsonMatchers;
import net.javacrumbs.jsonunit.core.Option;
import org.apache.commons.io.IOUtils;
import org.mockserver.integration.ClientAndServer;
import org.mockserver.matchers.MatchType;
import org.mockserver.model.HttpRequest;
import org.mockserver.model.HttpResponse;
import org.mockserver.model.JsonBody;
import org.mockserver.model.NottableString;
import org.mockserver.verify.VerificationTimes;
import org.slf4j.LoggerFactory;

/**
 * This class may be used to define expectations on output messages from a given service. When
 * expectations are setup, call the system under test THEN call {@link
 * #waitAndVerifyExpectedCall(Duration)} on your {@link ExpectedOutputReceiver } instance to check
 * if the expected messages where received (and optionally, check that no unwanted message was
 * received).
 */
public class ExpectedOutputReceiver {

  private ClientAndServer mockServer;
  private List<HttpRequest> expectedRequests = Collections.emptyList();
  private List<HttpRequest> unwantedRequests = Collections.emptyList();
  private JsonVariableMappings variableMappings = JsonVariableMappings.noMappings();
  private boolean ignoreArrayOrder = false;
  private int speedFactor = TestConfiguration.VALUES.getDurationFactorPercent();

  /**
   * Create an original receiver instance based on a given mock server.
   *
   * @param mockServer the server object to use.
   */
  public ExpectedOutputReceiver(ClientAndServer mockServer) {
    this.mockServer = mockServer;
  }

  /**
   * Create a complete expectation definition.
   *
   * @param mockServer the mock server instance to use.
   * @param expectedRequests a {@link List} of expected {@link HttpRequest}s : the receiver will
   *     verify that it got each request at least once after the wait delay.
   * @param unwantedRequests a {@link List} of unwanted {@link HttpRequest}s : the receiver will
   *     chaque that it was sent NONE of these requests after the wait delay.
   * @param variableMappings a {@link Map} describing key-value variableMappings to replace in JSON
   *     request templates.
   * @see #withVariableMapping(String, String)
   */
  public ExpectedOutputReceiver(
      ClientAndServer mockServer,
      List<HttpRequest> expectedRequests,
      List<HttpRequest> unwantedRequests,
      JsonVariableMappings variableMappings,
      boolean ignoreArrayOrder) {
    this.mockServer = mockServer;
    this.expectedRequests = new ArrayList<HttpRequest>(expectedRequests);
    this.unwantedRequests = new ArrayList<HttpRequest>(unwantedRequests);
    this.variableMappings = variableMappings;
    this.ignoreArrayOrder = ignoreArrayOrder;
  }

  /**
   * Static factory method to create an initial based on the given mock server. This is for use in
   * combination with the {@link #withExpectedRequests(HttpRequest...)} and {@link
   * #withUnwantedRequests(HttpRequest...)} to build a configured receiver instance.
   *
   * @param mockServer the mock server to use.
   * @return the instance.
   */
  public static ExpectedOutputReceiver basedOnMock(ClientAndServer mockServer) {
    return new ExpectedOutputReceiver(mockServer);
  }

  /**
   * Add variable mappings to build expected requests. the variable must be inserted on its own line
   * as #{key} as the value of a json property. The mapping must appear on its own line in the
   * template, like this (if there is no other property after it): <code>
   *                        "property": #{key}</code> or like this (if there is a property after
   * it): <code>                 "property": #{key},</code>
   *
   * @param key the key to replace. This must be an az-AZ-09+ string.
   * @param value the textual value by which to replace the variable construct.
   * @return the new {@link ExpectedOutputReceiver} instance.
   */
  public ExpectedOutputReceiver withVariableMapping(String key, String value) {
    if (expectedRequests.isEmpty() && unwantedRequests.isEmpty()) {
      JsonVariableMappings jsonVariableMappings =
          variableMappings.withAdditionalStringMapping(key, value);
      return new ExpectedOutputReceiver(
          mockServer,
          expectedRequests,
          unwantedRequests,
          jsonVariableMappings,
          this.ignoreArrayOrder);
    } else {
      throw new IllegalStateException(
          "Adding variables after adding expected requetst is unsupported");
    }
  }

  /**
   * Tells the mockserver to serve said resource. A mapping will be added for envelope substitution
   * (the mappng key will be base on the resource name with slashes replaced by underscores, the
   * value the exposed URL).
   *
   * @param attachmentResourceName the resource name. If this matchs no known resource, an {@link
   *     UnknownTestResource} exception will be thrown.
   * @throws IOException if resource access fails (may happen)
   * @throws URISyntaxException if the computed attachemnt URI is invalid (should NEVER happen)
   * @return the new receiver with a mapping for the resource URL.
   */
  public ExpectedOutputReceiver withMockAttachment(String attachmentResourceName)
      throws IOException, URISyntaxException {
    try (InputStream attachmentStream = getClass().getResourceAsStream(attachmentResourceName); ) {
      if (attachmentStream == null) {
        throw new UnknownTestResource("Resource not found: " + attachmentResourceName);
      }
      URI mockAttachmentURI =
          new URI(
              "http",
              null,
              TestConfiguration.VALUES.getMockHost(),
              this.mockServer.getPort(),
              attachmentResourceName,
              null,
              null);
      mockServer
          .when(HttpRequest.request(attachmentResourceName))
          .respond(
              HttpResponse.response()
                  .withStatusCode(200)
                  .withBody(IOUtils.toByteArray(attachmentStream)));
      return this.withVariableMapping(
          attachmentResourceName.replace('/', '_'), mockAttachmentURI.toString());
    }
  }

  public ExpectedOutputReceiver withExpectedRequestTemplate(String path, InputStream bodyStream)
      throws IOException {
    String bodyString = variableMappings.replaceMappings(bodyStream);

    List<HttpRequest> newExpectedRequestList = new ArrayList<HttpRequest>(this.expectedRequests);
    newExpectedRequestList.add(
        HttpRequest.request()
            .withPath(path)
            .withBody(JsonBody.json(bodyString, MatchType.ONLY_MATCHING_FIELDS)));

    mockServer
        .when(HttpRequest.request().withPath(path))
        .respond(HttpResponse.response().withStatusCode(SUTSender.HTTP_OK));

    return new ExpectedOutputReceiver(
        this.mockServer,
        newExpectedRequestList,
        unwantedRequests,
        variableMappings,
        this.ignoreArrayOrder);
  }

  public ExpectedOutputReceiver withExpectedRequests(HttpRequest... expectedRequests) {

    Arrays.asList(
            Objects.<HttpRequest[]>requireNonNull(
                expectedRequests, "expectedRequests cannot be null"))
        .forEach(
            oneReq -> {
              warnOfStrayVariableConstructOccurences(oneReq);

              mockServer
                  .when(HttpRequest.request().withPath(oneReq.getPath()))
                  .respond(HttpResponse.response().withStatusCode(SUTSender.HTTP_OK));
            });

    List<HttpRequest> newExpectedRequestList = new ArrayList<HttpRequest>(this.expectedRequests);
    newExpectedRequestList.addAll(Arrays.asList(expectedRequests));

    return new ExpectedOutputReceiver(
        this.mockServer,
        newExpectedRequestList,
        unwantedRequests,
        variableMappings,
        this.ignoreArrayOrder);
  }

  private void warnOfStrayVariableConstructOccurences(HttpRequest oneReq) {
    String expectedPayload = oneReq.getBodyAsString();

    List<String> occurences =
        JsonVariableMappings.searchForStrayVariableConstructs(expectedPayload);

    for (String occurence : occurences) {
      LoggerFactory.getLogger(ExpectedOutputReceiver.class)
          .warn("Found unreplaced variable construct {} in {}", occurence, expectedPayload);
    }
  }

  public ExpectedOutputReceiver withUnwantedRequests(HttpRequest... unwantedRequests) {

    List<HttpRequest> newUnwantedRequests = new ArrayList<HttpRequest>(this.unwantedRequests);

    newUnwantedRequests.addAll(Arrays.asList(unwantedRequests));

    return new ExpectedOutputReceiver(
        this.mockServer,
        this.expectedRequests,
        newUnwantedRequests,
        variableMappings,
        this.ignoreArrayOrder);
  }

  /**
   * Wait some time to give time for callbacks, then verify if expected requests were received, and
   * check that no unwanted request came.
   *
   * @param delay the base delay. A duration factor is applied based on {@link
   *     TestConfiguration#getDurationFactorPercent()}.
   * @return
   * @throws InterruptedException
   * @see TestConfiguration#getDurationFactorPercent()
   */
  public ExpectedOutputReceiver waitAndVerifyExpectedCall(Duration delay)
      throws InterruptedException {
    final long effectiveDelay = delay.multipliedBy(this.speedFactor).dividedBy(100).toMillis();
    LoggerFactory.getLogger(ExpectedOutputReceiver.class)
        .info(
            "This test specifies a {} ms delay, with factor {}%, we'll wait {} ms.",
            delay.toMillis(), speedFactor, effectiveDelay);

    Thread.sleep(effectiveDelay);

    for (HttpRequest oneReq : expectedRequests) {

      checkIfExpectedRequestWasReceived(oneReq);
    }

    try {
      for (HttpRequest oneReq : unwantedRequests) {

        mockServer.verify(oneReq, VerificationTimes.exactly(0));
      }
    } catch (AssertionError e) {
      throw new AssertionError("Unwanted request received", e);
    }

    return this;
  }

  /**
   * Create a receiver that ignores array element order. The default behavior is to check for array
   * element order.
   *
   * @return
   */
  public ExpectedOutputReceiver withIgnoreArrayElementOrder() {
    return new ExpectedOutputReceiver(
        this.mockServer, this.expectedRequests, this.unwantedRequests, this.variableMappings, true);
  }

  public JsonVariableMappings mappings() {
    return this.variableMappings;
  }

  private void checkIfExpectedRequestWasReceived(HttpRequest oneReq) {

    boolean found = false;

    LoggerFactory.getLogger(ExpectedOutputReceiver.class)
        .info("Checking for target request " + oneReq);
    NottableString path = oneReq.getPath();
    String expectedPayload = oneReq.getBodyAsString();

    StringBuilder actualBuilder = new StringBuilder();
    for (HttpRequest req :
        mockServer.retrieveRecordedRequests(HttpRequest.request().withPath(path))) {

      LoggerFactory.getLogger(ExpectedOutputReceiver.class).info("Went through request : " + req);

      String actualPayload = req.getBodyAsString();

      ConfigurableJsonMatcher<Object> matcher = JsonMatchers.jsonEquals(expectedPayload);
      if (ignoreArrayOrder) {
        matcher = matcher.when(Option.IGNORING_ARRAY_ORDER);
      }

      found |= matcher.matches(actualPayload);
      if (!found) {
        actualBuilder.append(actualPayload).append("\n");
      }
    }
    if (!found) {
      throw new AssertionError(
          "Expected request payload not found : expected<"
              + expectedPayload
              + "> but was <"
              + actualBuilder
              + ">");
    }
  }
}
