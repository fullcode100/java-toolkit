/*
 *  Copyright (c) 2020 - 2022 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.utils.process;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * Some static logic used by the process management subsystem.
 *
 * @author branchet
 */
public class CommandLine {

  private enum Status {
    OUTSIDE(""),
    IN_QUOTE("\'"),
    IN_DOUBLE_QUOTE("\"");

    String token;

    private Status(String token) {
      this.token = token;
    }
  }

  /**
   * Utility method to split a command line given as a unique string to an array of string
   *
   * @param commandLine The command line to parse
   * @return The splitted command line
   * @throws ParseException Exception thrown when an unbalanced quote is found in the command line
   *     to process.
   */
  public static String[] parse(String commandLine) throws ParseException {

    if (commandLine == null || commandLine.length() == 0) {
      return new String[0];
    }

    Status state = Status.OUTSIDE;

    StringTokenizer tokenized = new StringTokenizer(commandLine, "\"\' ", true);
    ArrayList<String> parsedCommand = new ArrayList<String>();
    StringBuilder argument = new StringBuilder();

    boolean lastTokenHasBeenQuoted = false;

    while (tokenized.hasMoreTokens()) {
      String nextToken = tokenized.nextToken();
      switch (state) {
        case IN_QUOTE:
          if ("\'".equals(nextToken)) {
            lastTokenHasBeenQuoted = true;
            state = Status.OUTSIDE;
          } else {
            argument.append(nextToken);
          }
          break;
        case IN_DOUBLE_QUOTE:
          if ("\"".equals(nextToken)) {
            lastTokenHasBeenQuoted = true;
            state = Status.OUTSIDE;
          } else {
            argument.append(nextToken);
          }
          break;
        default:
          if ("\'".equals(nextToken)) {
            state = Status.IN_QUOTE;
          } else if ("\"".equals(nextToken)) {
            state = Status.IN_DOUBLE_QUOTE;
          } else if (" ".equals(nextToken)) {
            if (lastTokenHasBeenQuoted || argument.length() != 0) {
              parsedCommand.add(argument.toString());
              argument.setLength(0);
            }
          } else {
            argument.append(nextToken);
          }
          lastTokenHasBeenQuoted = false;
          break;
      }
    }
    if (lastTokenHasBeenQuoted || argument.length() != 0) {
      parsedCommand.add(argument.toString());
    }
    if (!state.equals(Status.OUTSIDE)) {
      throw new ParseException(
          "Unable to parse command \"" + commandLine + "\". Unbalanced \"" + state.token + "\"",
          commandLine.length());
    }
    return parsedCommand.toArray(new String[parsedCommand.size()]);
  }
}
