/*
 *  Copyright (c) 2020 - 2022 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.utils.process;

import java.io.File;
import java.io.IOException;
import java.text.ParseException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeoutException;
import org.opentestfactory.utils.shell.ShellResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Client responsible to deal with the local system in process executing
 *
 * @author cruhlmann
 * @author bfranchet
 */
public class LocalProcessClient {
  /** Logger */
  private static final Logger LOGGER = LoggerFactory.getLogger(LocalProcessClient.class);

  private final Map<String, String> environment = new HashMap<>(System.getenv());

  /**
   * Convenience method to remove a single variable from the environment.
   *
   * @param name the name of the target variable.
   * @return <code>true</code> if the variable existed, <code>false</code> otherwise.
   */
  public boolean unsetEnvironementVariable(String name) {
    Set<String> uniset = new HashSet<>(1);
    uniset.add(name);
    return !unsetEnvironmentVariables(uniset).isEmpty();
  }

  /**
   * Remove some variables from the run environement.
   *
   * @param targetVariables names of the variables tpo unset.
   * @return name of the variables that were actually unset (only previously existing variables will
   *     be listed here).
   */
  public Set<String> unsetEnvironmentVariables(Set<String> targetVariables) {
    Set<String> removed = new HashSet<>(targetVariables.size());
    removed.addAll(targetVariables);
    removed.retainAll(environment.keySet());
    if (environment.keySet().removeAll(removed)) {
      LOGGER.debug(
          "Removed all the following environment variables : {} according to removal query of the"
              + " following vairables : {}.",
          removed,
          targetVariables);
    } else {
      LOGGER.warn("Failed to remove the following existing environment variable: {}", removed);
    }
    return removed;
  }

  /**
   * Convenience method to set one variable.
   *
   * @param name variable name.
   * @param value
   * @return the previous value if the variable was defined, <code>null</code> otherwise.
   */
  public String setEnvironmentVariable(String name, String value) {
    Map<String, String> asMap = new HashMap<>(1);
    asMap.put(name, value);
    Map<String, String> previousValue = setEnvironmentVariables(asMap);
    return previousValue.get(name);
  }

  /**
   * Method to set a bunch of environement variables.
   *
   * @param variables the variable mappins to set.
   * @return returns a map of replaced values for vairables that were already defined.
   */
  public Map<String, String> setEnvironmentVariables(Map<String, String> variables) {
    Map<String, String> previouslyExisting = new HashMap<>(environment);
    previouslyExisting.keySet().retainAll(variables.keySet());
    environment.putAll(variables);
    LOGGER.debug(
        "Set the following variables {}, replacing the following pre-existing mappings: {}",
        variables,
        previouslyExisting);
    return previouslyExisting;
  }

  /**
   * This method execute a single command line on the local system.
   *
   * @param command The command to execute
   * @param workingDir The working directory for the launched command. If set to null, the default
   *     working directory will be used.
   * @param timeout The timeout (in ms) before the process gets killed and you get shouted at. If
   *     set to 0 or a negative value, no timeout will be applied.
   * @param streamlength The max stream length to keep (number of characters).
   * @return a ShellResult
   * @throws IOException
   * @throws InterruptedException
   * @throws TimeoutException
   * @throws ParseException
   */
  public ShellResult runLocalProcessCommand(
      String command, File workingDir, Integer timeout, Integer streamlength)
      throws IOException, InterruptedException, TimeoutException, ParseException {

    String[] parsedCommand = CommandLine.parse(command);
    ProcessBuilder processBuilder = new ProcessBuilder(parsedCommand);
    if (workingDir != null) {
      processBuilder.directory(workingDir);
    }
    if (timeout.intValue() < 0) {
      timeout = new Integer(0);
    }
    if (streamlength.intValue() < -1) {
      streamlength = new Integer(0);
    }
    LOGGER.debug("Beginning execution of the command '" + command + "'.");

    processBuilder.environment().clear();
    processBuilder.environment().putAll(environment);

    LOGGER.trace("Command environment : {}", processBuilder.environment());

    Process proc = processBuilder.start();
    ProcessHandle handle = new ProcessHandle("Local process", proc, true, true, true, streamlength);
    Worker worker = new Worker(proc);
    worker.start();
    try {
      worker.join(timeout);
      if (worker.getExitCode() != null) {
        return new ShellResult(
            handle.returnValue(), handle.getStdoutStream(), handle.getErrorStream(), command);
      } else {
        StringBuilder builder =
            new StringBuilder("Command ")
                .append(command)
                .append(" timed out (")
                .append(timeout)
                .append(" ms)\n");
        if (handle.getStdoutStream() != null) {
          builder.append("At timeout stdout was: ").append(handle.getStdoutStream()).append("\n");
        }
        if (handle.getErrorStream() != null) {
          builder.append("At timeout stderr was: ").append(handle.getErrorStream()).append("\n");
        }
        throw new TimeoutException(builder.toString());
      }
    } catch (InterruptedException ex) {
      worker.interrupt();
      Thread.currentThread().interrupt();
      throw ex;
    } finally {
      handle.killProcess();
    }
  }
}

// this class allows us to deal with the timeout property
class Worker extends Thread {

  private final Process process;
  private Integer exitCode;

  Worker(Process process) {
    this.process = process;
  }

  Integer getExitCode() {
    return exitCode;
  }

  @Override
  public void run() {
    try {
      exitCode = process.waitFor();
    } catch (InterruptedException e) {
      return;
    }
  }
}
