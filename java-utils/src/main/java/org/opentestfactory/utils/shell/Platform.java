/*
 *  Copyright (c) 2020 - 2023 Henix, henix.fr
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.opentestfactory.utils.shell;

import java.util.Iterator;
import org.apache.commons.lang.SystemUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * For testability, we encapsulate plateform-dependant behavior in a strategy family.
 *
 * @author edegenetais
 */
public abstract class Platform {
  private static final Logger LOGGER = LoggerFactory.getLogger(Platform.class);
  /**
   * @deprecated This field is package-accessible FOR UNIT TESTS ONLY, and should NEVER be used in
   *     business code
   */
  @Deprecated static Platform INSTANCE;

  static {
    if (SystemUtils.IS_OS_WINDOWS) {
      INSTANCE = new WindowsPlatform();
    } else {
      INSTANCE = new PosixPlatform();
    }
  }

  /**
   * This function returns a {@link Platform} instance tuned to the local platform.
   *
   * @return the {@link Platform} instance.
   */
  public static final Platform getLocalPlatform() {
    /** This is the Only Legitimate Use Business-Side (R)(c)(tm) ! */
    return INSTANCE;
  }

  public abstract String getPlatformStatementSeparator();
  /**
   * Depending on what works or doesn't on the platform, may decide wether to open a shell. Opening
   * a shell may be done for example in order to obtain shell interpreter functions that are
   * unavailable when we are merely creating a new process wiht the first command part as executable
   * name. Shell opening is performed by adding platform specific parts to the commandline before
   * executing it.
   *
   * @param localCommand the local command string.
   * @return the localCommand string with shell-opening part added.
   */
  public String addShellSpawnCommandIfNeeded(String localCommand) {
    if (isMultistatement(localCommand) | needsShellOnPlatform(localCommand)) {
      return changeIntoInSHellCommand(localCommand);
    } else {
      return localCommand;
    }
  }

  protected boolean isMultistatement(String localCommand) {
    return localCommand.indexOf(getPlatformStatementSeparator()) > 0;
  }

  protected abstract boolean needsShellOnPlatform(String command);

  protected abstract String prepareStatement(String query);

  /**
   * Perform platform-related changes to prepare the command string for execution.
   *
   * @param lineIterator
   * @param command
   */
  public void addStatementFromLine(Iterator<String> lineIterator, StringBuffer command) {
    final String line = lineIterator.next();
    final String preparedStatement = prepareStatement(line);
    if (!preparedStatement.isEmpty()) {
      LOGGER.debug("Command file line: {}", line);
      command.append(preparedStatement);
    }
  }

  protected abstract String changeIntoInSHellCommand(String localCommand);
}
